{"version":3,"sources":["webpack://mason/webpack/universalModuleDefinition","webpack://mason/webpack/bootstrap","webpack://mason/./src/shared.ts","webpack://mason/./src/booleanProcessor.ts","webpack://mason/./src/types.ts","webpack://mason/./src/index.ts","webpack://mason/./src/ReactRenderer.ts","webpack://mason/external \"react\"","webpack://mason/./src/eventHandling.ts","webpack://mason/./src/validator.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__5__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","INTERPOLATION_REGEX","processValue","rootState","selfValue","test","matchedResults","match","interpolatedValue","forEach","matchedResult","fullInterpolatedText","fieldId","processedValue","replace","JSON","stringify","capitalize","str","charAt","toUpperCase","slice","booleanConfigProcessor","booleanConfig","type","OperationType","ATOMIC","leftOperand","rightOperand","operator","ComparisonOperators","EQ","NOT_EQ","LT","LTE","GT","GTE","atomicBooleanProcessor","COMPOUND","CompoundOperators","AND","OR","compoundBooleanProcessor","booleanProcessor","booleanClause","ValidationTypes","reducer","state","payload","id","props","Error","prop","draft","entries","val","context","createContext","constructStateFromValue","config","values","meta","children","childConfigNode","RootComponentCore","forwardRef","ref","initialState","useReducer","useImperativeHandle","setRootState","newState","dispatch","action","createElement","Provider","RootComponent","memo","ReactConfigRenderer","elementsMap","options","components","Map","this","renderConfigNode","currentRootStateSnapshot","rootComponentRef","node","data","events","validations","style","show","dataProcessors","onStateChange","elementComponent","componentId","wrappedComponent","useContext","rootDispatch","isValuedBeingUpdated","validationErrors","validator","wrappedDispatch","eventsMap","useMemo","reduce","eventsObj","eventName","eventConfig","event","Array","isArray","handleEvent","useEffect","component","showCondition","undefined","displayName","map","initialValues","acc","current","constructInitialState","useRef","when","endpoint","queryParams","dataProcessor","fieldIds","credentials","error","fetch","push","join","formQueryString","target","then","response","ok","json","result","fieldIdTemp","fieldDataProcessor","e","Response","text","console","message","dataSource","finalValue","errors","validation","REQUIRED","pattern","RegExp","REGEX","min","max","length","LENGTH","RANGE"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mason\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"mason\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__5__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const INTERPOLATION_REGEX = /(<%[^%>]+%>)/g;\n\nexport const processValue = (value: string, rootState: { [k: string]: any }, selfValue?: string): string => {\n  const isInterpolated = INTERPOLATION_REGEX.test(value);\n  if (isInterpolated) {\n    /**\n     * To match the interpolations repetitively\n     * \"foo<%bar%>baz<%bax%>lorem<%ipsum%>dolor\".match(/(<%[^%>]+%>)/g)\n     *  => [\"<%bar%>\", \"<%bax%>\", \"<%ipsum%>\"]\n     */\n    const matchedResults = value.match(INTERPOLATION_REGEX);\n    let interpolatedValue = value;\n    if (matchedResults) {\n      matchedResults.forEach(matchedResult => {\n        /**\n         * For each of the interpolations matched, the inner valuable text needs to be extracted\n         * and processed for finding corresponding value against the field id in the rootState or self\n         * eventually replacing the interpolation with the processed value\n         * \"<%foo%>\".match(/^<%([^%>]+)%>$/)\n         * => [\"<%foo%>\", \"foo\", index: 0, input: \"<%foo%>\", groups: undefined]\n         */\n        const extractIdMatch = matchedResult.match(/^<%([^%>]+)%>$/);\n        const [fullInterpolatedText, fieldId] = extractIdMatch || [\"\", \"\"];\n        const processedValue = fieldId === \"SELF\" ? selfValue : rootState[fieldId] && rootState[fieldId].value;\n        interpolatedValue = interpolatedValue.replace(\n          fullInterpolatedText,\n          typeof processedValue !== \"string\" ? JSON.stringify(processedValue) : processedValue\n        );\n      });\n    }\n    return interpolatedValue;\n  }\n  return typeof value !== \"string\" ? JSON.stringify(value) : value;\n};\n\nexport const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n","import { processValue } from \"./shared\";\nimport { ComparisonOperators, CompoundOperators, BooleanConfig, OperationType } from \"./types\";\n\nconst atomicBooleanProcessor = (operator: ComparisonOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case ComparisonOperators.EQ:\n      return leftOperand === rightOperand;\n    case ComparisonOperators.NOT_EQ:\n      return leftOperand !== rightOperand;\n    case ComparisonOperators.LT:\n      return leftOperand < rightOperand;\n    case ComparisonOperators.LTE:\n      return leftOperand <= rightOperand;\n    case ComparisonOperators.GT:\n      return leftOperand > rightOperand;\n    case ComparisonOperators.GTE:\n      return leftOperand >= rightOperand;\n  }\n};\n\nconst compoundBooleanProcessor = (operator: CompoundOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case CompoundOperators.AND:\n      return leftOperand && rightOperand;\n    case CompoundOperators.OR:\n      return leftOperand || rightOperand;\n  }\n};\n\nconst booleanConfigProcessor = (booleanConfig: BooleanConfig, rootState, selfValue?: any): boolean => {\n  const { type: operationType } = booleanConfig;\n  switch (operationType) {\n    case OperationType.ATOMIC: {\n      const leftOperand = processValue(booleanConfig.leftOperand as string, rootState, selfValue);\n      const rightOperand = processValue(booleanConfig.rightOperand as string, rootState, selfValue);\n      return atomicBooleanProcessor(booleanConfig.operator as ComparisonOperators, leftOperand, rightOperand);\n    }\n    case OperationType.COMPOUND: {\n      const leftOperand = booleanConfigProcessor(booleanConfig.leftOperand as BooleanConfig, rootState);\n      const rightOperand = booleanConfigProcessor(booleanConfig.rightOperand as BooleanConfig, rootState);\n      return compoundBooleanProcessor(booleanConfig.operator as CompoundOperators, leftOperand, rightOperand);\n    }\n  }\n};\n\nexport const booleanProcessor = (booleanClause: boolean | BooleanConfig, rootState, selfValue?: any) => {\n  if (typeof booleanClause === \"boolean\") {\n    return booleanClause;\n  }\n  return booleanConfigProcessor(booleanClause as BooleanConfig, rootState, selfValue);\n};\n","export interface ITypeMeta {\n  type: string;\n  meta?: any;\n}\n/** Boolean Configs */\nexport enum ComparisonOperators {\n  EQ = \"=\",\n  NOT_EQ = \"!=\",\n  LT = \"<\",\n  LTE = \"<=\",\n  GT = \">\",\n  GTE = \">=\"\n}\n\nexport enum CompoundOperators {\n  AND = \"&&\",\n  OR = \"||\"\n}\n\nexport enum OperationType {\n  ATOMIC = \"ATOMIC\",\n  COMPOUND = \"COMPOUND\"\n}\n\nexport type BooleanConfig = {\n  type: OperationType;\n  operator: ComparisonOperators | CompoundOperators;\n  leftOperand: string | BooleanConfig;\n  rightOperand: string | BooleanConfig;\n};\n\n/** Boolean Configs */\n\n/** Validator Types */\n\nexport enum ValidationTypes {\n  REQUIRED = \"REQUIRED\",\n  REGEX = \"REGEX\",\n  CUSTOM = \"CUSTOM\",\n  RANGE = \"RANGE\",\n  LENGTH = \"LENGTH\",\n  JSON = \"JSON\"\n}\n\nexport interface IValidationConfig extends ITypeMeta {\n  type: ValidationTypes;\n}\n\n/** Validator Types */\n\nexport type IDataFieldConfig = IDataSetDatasourceConfig | IDataAjaxConfig | IDataAjaxConfig;\n\nexport interface IEventsConfig extends ITypeMeta {\n  type: \"AJAX_CALL\" | \"SET_DATASOURCE\" | \"SET_VALUE\" | \"CUSTOM\";\n  when?: BooleanConfig;\n}\nexport interface IDataAjaxConfig {\n  type: \"AJAX_CALL\";\n  meta: {\n    endpoint: string;\n    queryParams: {\n      [k: string]: string;\n    };\n    credentials?: \"include\" | \"same-origin\" | \"omit\";\n    fieldId?: string;\n    dataProcessor?: string;\n    fieldIds?: { [k: string]: string };\n  };\n}\n\nexport interface IDataSetValueConfig {\n  type: \"SET_VALUE\";\n  meta: {\n    value: any;\n    fieldId?: string;\n  };\n}\n\nexport interface IDataSetDatasourceConfig {\n  type: \"SET_DATASOURCE\";\n  meta: {\n    data: any;\n    fieldId?: string;\n  };\n}\n\nexport interface ICustomHandlerConfig {\n  type: \"CUSTOM\";\n  meta: {\n    name: string;\n  };\n}\n\nexport interface IConfigNode {\n  id: string;\n  type: string;\n  children?: Array<IConfigNode>;\n  meta?: any;\n  style?: any;\n  show?: boolean | BooleanConfig;\n  validations?: Array<IValidationConfig>;\n  events?: {\n    [eventName: string]: Array<IEventsConfig> | IEventsConfig;\n  };\n  data?: Pick<IDataFieldConfig, keyof IDataFieldConfig>;\n}\n\nexport interface IConfig {\n  page: string;\n  config: IConfigNode;\n}\n\nexport interface IConfigRenderer<ReturnNodeType = any> {\n  readonly config: IConfig;\n  render: () => ReturnNodeType;\n}\n","export * from \"./ReactRenderer\";\n","/* eslint-disable react/display-name */\nimport React, {\n  createContext,\n  memo,\n  useReducer,\n  createElement,\n  useContext,\n  useEffect,\n  useMemo,\n  Dispatch,\n  forwardRef,\n  useRef,\n  useImperativeHandle\n} from \"react\";\nimport { IConfigRenderer, IConfig, IConfigNode, IValidationConfig } from \"./types\";\nimport { handleEvent } from \"./eventHandling\";\nimport { validator } from \"./validator\";\n\n// import produce from \"immer\";\nimport { booleanProcessor } from \"./booleanProcessor\";\nimport { capitalize } from \"./shared\";\n\nconst getWrapperComponentName = (componentId: string) => `${capitalize(componentId)}MasonWrapper`;\n\nexport type ActionType = {\n  type: string;\n  payload: any;\n};\n\n/*\nconst immerReducer = (state, { type, payload }) => {\n  return produce(state, draft => {\n    switch (type) {\n      case \"ADD_ENTRY\":\n        draft[payload.id] = payload.props;\n        break;\n      case \"UPDATE_ENTRY\":\n        draft[payload.id] = { ...state[payload.id], ...payload.props };\n        break;\n      case \"UPDATE_PROP\":\n        {\n          if (!state[payload.id]) {\n            throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n          }\n          draft[payload.id][payload.prop] = payload.value;\n        }\n        break;\n      case \"REPLACE_STATE_VALUES\":\n        for (const [key, val] of Object.entries(payload)) {\n          draft[key][\"value\"] = (val as any).value;\n        }\n        break;\n    }\n  });\n};\n*/\n\nconst reducer = (state, { type, payload }) => {\n  switch (type) {\n    case \"ADD_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: payload.props\n      };\n    case \"UPDATE_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: { ...state[payload.id], ...payload.props }\n      };\n    case \"UPDATE_PROP\": {\n      if (!state[payload.id]) {\n        throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n      }\n      return {\n        ...state,\n        [payload.id]: {\n          ...state[payload.id],\n          [payload.prop]: payload.value\n        }\n      };\n    }\n\n    case \"REPLACE_STATE_VALUES\": {\n      const draft = { ...state };\n      for (const [key, val] of Object.entries(payload)) {\n        draft[key][\"value\"] = (val as any).value;\n      }\n      return draft;\n    }\n\n    default:\n      return state;\n  }\n};\n\nexport type IRendererOptions = {\n  initialValues?: Map<string, any>;\n  dataProcessors?: {\n    [k: string]: (a: any) => any;\n  };\n  onStateChange?: (state: { [k: string]: any }) => void;\n};\n\ntype IRendererContext = {\n  state: IObject;\n  dispatch: Dispatch<{\n    type: string;\n    payload: any;\n  }>;\n};\n\nconst context = createContext<IRendererContext>(null as any);\n\nconst wrappedDispatch = (\n  dispatch: React.Dispatch<ActionType>,\n  validations: Array<IValidationConfig> = [],\n  options?: { onStateChange?: IRendererOptions[\"onStateChange\"] }\n) => ({ type, payload }) => {\n  const isValuedBeingUpdated = type === \"UPDATE_PROP\" && payload.prop === \"value\";\n  if (isValuedBeingUpdated) {\n    const { value, id: fieldId } = payload;\n    const validationErrors = validator(validations, value);\n\n    dispatch({\n      type: \"UPDATE_PROP\",\n      payload: {\n        id: fieldId,\n        prop: \"validations\",\n        value: validationErrors\n      }\n    });\n  }\n  const state = dispatch({ type, payload });\n  if (options && options.onStateChange && isValuedBeingUpdated) {\n    options.onStateChange(reducer(state, { type, payload }));\n  }\n};\n\nfunction constructStateFromValue(config: IConfigNode, state, values: Map<string, any>) {\n  const { meta, id, children } = config;\n  if (values && values.get(id)) {\n    state[id] = { ...(state[id] || {}), value: values.get(id) };\n  } else if (meta && typeof meta.value !== \"undefined\") {\n    state[id] = { ...(state[id] || {}), value: meta.value };\n  }\n  if (children) {\n    children.forEach(childConfigNode => constructStateFromValue(childConfigNode, state, values));\n  }\n  return state;\n}\n\nconst RootComponentCore: React.ForwardRefExoticComponent<{\n  initialState: any;\n}> = forwardRef(({ children, initialState = {} }, ref) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  useImperativeHandle(\n    ref,\n    () => ({\n      setRootState(config: IConfigNode, val) {\n        const newState = constructStateFromValue(config, { ...state }, val);\n        dispatch({ type: \"REPLACE_STATE_VALUES\", payload: newState });\n      }\n    }),\n    [state]\n  );\n\n  const props = {\n    value: {\n      state,\n      dispatch: (action: ActionType) => {\n        dispatch(action);\n        return state;\n      }\n    }\n  };\n  return createElement(context.Provider, props, children);\n});\n\nexport const RootComponent: React.NamedExoticComponent<any> = memo(RootComponentCore);\n\ntype IObject = {\n  [k: string]: any;\n};\n\n// const eventsSeedValue = {};\n\nexport class ReactConfigRenderer implements IConfigRenderer<React.ReactNode> {\n  private components: Map<string, React.Component> = new Map();\n  readonly config: IConfig;\n  private elementsMap: Map<string, React.ComponentType<any>>;\n  private options: IObject;\n  private currentRootStateSnapshot: IObject;\n  private rootComponentRef: React.MutableRefObject<any> | null;\n  constructor(config: IConfig, elementsMap: Map<string, React.ComponentType<any>>, options?: IRendererOptions) {\n    this.config = config;\n    this.elementsMap = elementsMap;\n    this.options = options || {};\n    this.renderConfigNode = this.renderConfigNode.bind(this);\n    this.currentRootStateSnapshot = {};\n    this.rootComponentRef = null;\n  }\n  renderConfigNode(node: IConfigNode) {\n    const { id, type, meta = {}, data, events = {}, validations, children, style, show } = node;\n    const { dataProcessors = {}, onStateChange } = this.options;\n    // if (this.components.has(id)) return this.components.get(id);\n    const elementComponent = this.elementsMap.get(type);\n    if (!elementComponent) {\n      throw new Error(`No component exists for type ${type}`);\n    }\n    const wrappedComponent: React.MemoExoticComponent<any> & { whyDidYouRender?: boolean } = memo(props => {\n      /** Getting the reducer context as a consumer for reading the state and dispatching actions */\n      const { state: rootState, dispatch } = useContext(context);\n\n      const rootDispatch = wrappedDispatch(dispatch, validations, { onStateChange });\n      this.currentRootStateSnapshot = rootState;\n      /** Creating the event handlers out of the events config */\n      const eventsMap = useMemo(() => {\n        return Object.entries(events).reduce((eventsObj, [eventName, eventConfig]) => {\n          const eventHandler = (event: Event, value?: any) => {\n            /** Executing multiple event handlers in case an array is provided against an event type in config */\n            if (Array.isArray(eventConfig)) {\n              eventConfig.forEach(config => {\n                handleEvent(config, { id, event, dataProcessors, value }, rootDispatch, rootState);\n              });\n            } else {\n              handleEvent(eventConfig, { id, event, dataProcessors, value }, rootDispatch, rootState);\n            }\n          };\n          eventsObj[eventName] = eventHandler;\n          return eventsObj;\n        }, {});\n      }, [events, rootState, rootDispatch]);\n\n      /** Storing the component and its props in the rootState on mounting */\n      useEffect(() => {\n        rootDispatch({\n          type: rootState[id] ? \"UPDATE_ENTRY\" : \"ADD_ENTRY\",\n          payload: {\n            id,\n            props: { ...meta, ...props, value: rootState[id] ? rootState[id].value : meta.value }\n          }\n        });\n        /** Checking if data key is provided in the config and setting the datasource on component Mount */\n        if (data) {\n          handleEvent(data, { id, dataProcessors }, rootDispatch, rootState);\n        }\n      }, []);\n\n      /** Constructing the original component by setting its props from the rootState and returning it */\n      const component = React.useMemo(\n        () =>\n          createElement(\n            elementComponent,\n            { ...(rootState[id] ? rootState[id] : { ...meta, ...props }), ...eventsMap },\n            props.children\n          ),\n        [rootState[id], eventsMap, props.children]\n      );\n      const showCondition: boolean = show !== undefined ? booleanProcessor(show, rootState) : true;\n      useEffect(() => {\n        /**\n         * Check if the element has been hidden based on the show condition above and\n         * hence reset it's value into the rootState.\n         */\n        if (!showCondition && rootState[id] && typeof rootState[id].value !== \"undefined\") {\n          rootDispatch({\n            type: \"UPDATE_PROP\",\n            payload: {\n              id,\n              prop: \"value\",\n              value: meta.value\n            }\n          });\n        }\n      }, [showCondition]);\n\n      return showCondition ? createElement(\"section\", props, component) : null;\n    });\n    wrappedComponent.displayName = getWrapperComponentName(id);\n    // wrappedComponent.whyDidYouRender = true;\n    const el = createElement(\n      wrappedComponent,\n      { key: id, style, id },\n      ...(children ? children.map(this.renderConfigNode) : [])\n    );\n    // this.components.set(id, el);\n    return el;\n  }\n\n  constructInitialState(config: IConfigNode, initialState) {\n    const { initialValues } = this.options;\n    return constructStateFromValue(config, initialState, initialValues);\n  }\n\n  getCurrentValuesSnapshot() {\n    return Object.entries(this.currentRootStateSnapshot).reduce((acc, [key, val]) => {\n      if (typeof val.value !== \"undefined\") {\n        acc[key] = val.value;\n      }\n      return acc;\n    }, {});\n  }\n\n  public setValue(val) {\n    if (this.rootComponentRef) {\n      this.rootComponentRef.current.setRootState(this.config.config, val);\n    }\n  }\n\n  render() {\n    return memo(() => {\n      const { config } = this.config;\n      const initialState = this.constructInitialState(config, {});\n      this.rootComponentRef = useRef();\n      return createElement(RootComponent, { initialState, ref: this.rootComponentRef }, [this.renderConfigNode(config)]);\n    });\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","import {\n  IDataAjaxConfig,\n  IDataSetDatasourceConfig,\n  IDataSetValueConfig,\n  IEventsConfig,\n  ICustomHandlerConfig\n} from \"./types\";\nimport { processValue } from \"./shared\";\nimport { booleanProcessor } from \"./booleanProcessor\";\n\ninterface IOptions {\n  id: string;\n  event?: Event | null;\n  value?: any;\n  dataProcessors: {};\n}\n\nconst formQueryString = (queryParams, rootState, selfValue) =>\n  Object.entries(queryParams)\n    .reduce((acc: Array<string>, [key, value]) => {\n      acc.push(`${key}=${processValue(value as string, rootState, selfValue)}`);\n      return acc;\n    }, [])\n    .join(\"&\");\n\nexport const handleEvent = (\n  eventConfig: IEventsConfig,\n  { id, event = null, dataProcessors, value = undefined }: IOptions,\n  rootDispatch,\n  rootState\n) => {\n  const { type, when } = eventConfig;\n\n  /**\n   * Checking if the when clause/config is passed into the event config, process it by passing through\n   * the boolean processor and stop proceeding if it returns falsy\n   */\n  if (when) {\n    const shouldProceed = booleanProcessor(when, rootState, value);\n    if (shouldProceed === false) {\n      return;\n    }\n  }\n  switch (type) {\n    case \"AJAX_CALL\":\n      {\n        const {\n          endpoint,\n          queryParams,\n          dataProcessor,\n          fieldId,\n          fieldIds,\n          credentials = \"omit\"\n        } = (eventConfig as IDataAjaxConfig).meta;\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"loading\",\n            value: true\n          }\n        });\n\n        if (rootState[fieldId || id] && rootState[fieldId || id].error) {\n          rootDispatch({\n            type: \"UPDATE_PROP\",\n            payload: {\n              id: fieldId || id,\n              prop: \"error\",\n              value: null\n            }\n          });\n        }\n\n        fetch(\n          `${endpoint}?${\n            queryParams\n              ? formQueryString(\n                  queryParams,\n                  rootState,\n                  value !== undefined ? value : event ? (event.target as HTMLFormElement).value : null\n                )\n              : \"\"\n          }`,\n          {\n            credentials\n          }\n        )\n          .then(response => {\n            if (response.ok) return response.json();\n            throw response;\n          })\n          .then(result => (dataProcessor && dataProcessors[dataProcessor] ? dataProcessors[dataProcessor](result) : result))\n          .then(result => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n            /** If datasource of multiple elements (usually children) needs to be set, fieldIds needs to be intercepted */\n            if (fieldIds) {\n              for (const [fieldIdTemp, fieldDataProcessor] of Object.entries(fieldIds)) {\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldIdTemp,\n                    prop: \"datasource\",\n                    value: dataProcessors && dataProcessors[fieldDataProcessor] && dataProcessors[fieldDataProcessor](result)\n                  }\n                });\n              }\n            } else {\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"datasource\",\n                  value: result\n                }\n              });\n            }\n          })\n          .catch(e => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n\n            if (e instanceof Response) {\n              e.text().then(error => {\n                console.error(`Error while fetching datasource: `, error);\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldId || id,\n                    prop: \"error\",\n                    value: error\n                  }\n                });\n              });\n            } else {\n              console.error(`Error while fetching datasource: `, e);\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"error\",\n                  value: (e as TypeError).message\n                }\n              });\n            }\n          });\n      }\n      break;\n    case \"SET_DATASOURCE\":\n      {\n        const { data: dataSource, fieldId } = (eventConfig as IDataSetDatasourceConfig).meta;\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"datasource\",\n            value: dataSource\n          }\n        });\n      }\n      break;\n    case \"SET_VALUE\":\n      {\n        const { meta } = eventConfig as IDataSetValueConfig;\n        let finalValue = null;\n        if (typeof meta !== \"undefined\" && meta.value) {\n          finalValue = meta.value;\n        } else if (typeof value !== \"undefined\") {\n          finalValue = value;\n        } else {\n          finalValue = event && (event.target as HTMLFormElement).value;\n        }\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: (meta && meta.fieldId) || id,\n            prop: \"value\",\n            value: finalValue\n          }\n        });\n      }\n      break;\n    case \"CUSTOM\":\n      {\n        const { meta } = eventConfig as ICustomHandlerConfig;\n        if (dataProcessors && dataProcessors[meta.name]) {\n          dataProcessors[meta.name]({ event, value, id });\n        }\n      }\n      break;\n    default:\n      throw new Error(\"No valid data type provided in config\");\n  }\n};\n","import { IValidationConfig, ValidationTypes } from \"./types\";\n\nexport const validator = (validations: Array<IValidationConfig> = [], value: any) =>\n  validations.reduce((errors: { [k in ValidationTypes]?: string }, validation: IValidationConfig) => {\n    switch (validation.type) {\n      case ValidationTypes.REQUIRED:\n        {\n          if (value === \"\" || value === null || value === undefined) {\n            errors[ValidationTypes.REQUIRED] = `This field is required`;\n          } else {\n            errors[ValidationTypes.REQUIRED] = \"\";\n          }\n        }\n        break;\n      case \"REGEX\":\n        {\n          const {\n            meta: { pattern }\n          } = validation;\n          if (!new RegExp(pattern).test(value)) {\n            errors[ValidationTypes.REGEX] = `Field value doesn't match the pattern`;\n          } else {\n            errors[ValidationTypes.REGEX] = \"\";\n          }\n        }\n        break;\n      case \"LENGTH\":\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (value.length < min) {\n            errors[ValidationTypes.LENGTH] = `Minimum length of ${min} is needed`;\n          } else if (value.length > max) {\n            errors[ValidationTypes.LENGTH] = `Maximum length of ${max} is allowed`;\n          } else {\n            errors[ValidationTypes.LENGTH] = \"\";\n          }\n        }\n        break;\n      case \"RANGE\":\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (!(value > min && value < max)) {\n            errors[ValidationTypes.RANGE] = `The value should be in the range of ${min} and ${max}`;\n          } else {\n            errors[ValidationTypes.RANGE] = \"\";\n          }\n        }\n        break;\n    }\n    return errors;\n  }, {});\n"],"sourceRoot":""}