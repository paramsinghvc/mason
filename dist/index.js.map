{"version":3,"sources":["webpack://mason/webpack/universalModuleDefinition","webpack://mason/webpack/bootstrap","webpack://mason/./src/shared.ts","webpack://mason/./src/booleanProcessor.ts","webpack://mason/./src/types.ts","webpack://mason/./src/index.ts","webpack://mason/./src/ReactRenderer.ts","webpack://mason/external \"react\"","webpack://mason/./src/eventHandling.ts","webpack://mason/./src/validator.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__5__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","INTERPOLATION_REGEX","processValue","rootState","selfValue","test","matchedResults","match","interpolatedValue","forEach","matchedResult","fullInterpolatedText","fieldId","processedValue","replace","JSON","stringify","capitalize","str","charAt","toUpperCase","slice","booleanConfigProcessor","booleanConfig","type","OperationType","ATOMIC","leftOperand","rightOperand","operator","ComparisonOperators","EQ","NOT_EQ","LT","LTE","GT","GTE","atomicBooleanProcessor","COMPOUND","CompoundOperators","AND","OR","compoundBooleanProcessor","booleanProcessor","booleanClause","ValidationTypes","reducer","state","payload","id","props","Error","prop","draft","entries","val","context","createContext","constructStateFromValue","config","values","meta","children","childConfigNode","RootComponentCore","forwardRef","ref","initialState","useReducer","dispatch","useImperativeHandle","setRootState","newState","createElement","Provider","RootComponent","memo","ReactConfigRenderer","elementsMap","options","components","Map","this","renderConfigNode","currentRootStateSnapshot","rootComponentRef","node","data","events","validations","style","show","dataProcessors","elementComponent","componentId","wrappedComponent","useContext","rootDispatch","validationErrors","validator","wrappedDispatch","eventsMap","useMemo","reduce","eventsObj","eventName","eventConfig","event","Array","isArray","handleEvent","useEffect","component","showCondition","undefined","displayName","map","initialValues","acc","current","constructInitialState","useRef","when","endpoint","queryParams","dataProcessor","fieldIds","credentials","fetch","push","join","formQueryString","target","then","response","ok","json","result","fieldIdTemp","fieldDataProcessor","e","Response","text","error","console","dataSource","finalValue","errors","validation","REQUIRED","pattern","RegExp","REGEX","min","max","length","LENGTH","RANGE"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mason\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"mason\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__5__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const INTERPOLATION_REGEX = /(<%[^%>]+%>)/g;\n\nexport const processValue = (value: string, rootState: { [k: string]: any }, selfValue?: string): string => {\n  const isInterpolated = INTERPOLATION_REGEX.test(value);\n  if (isInterpolated) {\n    /**\n     * To match the interpolations repetitively\n     * \"foo<%bar%>baz<%bax%>lorem<%ipsum%>dolor\".match(/(<%[^%>]+%>)/g)\n     *  => [\"<%bar%>\", \"<%bax%>\", \"<%ipsum%>\"]\n     */\n    const matchedResults = value.match(INTERPOLATION_REGEX);\n    let interpolatedValue = value;\n    if (matchedResults) {\n      matchedResults.forEach(matchedResult => {\n        /**\n         * For each of the interpolations matched, the inner valuable text needs to be extracted\n         * and processed for finding corresponding value against the field id in the rootState or self\n         * eventually replacing the interpolation with the processed value\n         * \"<%foo%>\".match(/^<%([^%>]+)%>$/)\n         * => [\"<%foo%>\", \"foo\", index: 0, input: \"<%foo%>\", groups: undefined]\n         */\n        const extractIdMatch = matchedResult.match(/^<%([^%>]+)%>$/);\n        const [fullInterpolatedText, fieldId] = extractIdMatch || [\"\", \"\"];\n        const processedValue = fieldId === \"SELF\" ? selfValue : rootState[fieldId] && rootState[fieldId].value;\n        interpolatedValue = interpolatedValue.replace(\n          fullInterpolatedText,\n          typeof processedValue !== \"string\" ? JSON.stringify(processedValue) : processedValue\n        );\n      });\n    }\n    return interpolatedValue;\n  }\n  return typeof value !== \"string\" ? JSON.stringify(value) : value;\n};\n\nexport const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n","import { processValue } from \"./shared\";\nimport { ComparisonOperators, CompoundOperators, BooleanConfig, OperationType } from \"./types\";\n\nconst atomicBooleanProcessor = (operator: ComparisonOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case ComparisonOperators.EQ:\n      return leftOperand === rightOperand;\n    case ComparisonOperators.NOT_EQ:\n      return leftOperand !== rightOperand;\n    case ComparisonOperators.LT:\n      return leftOperand < rightOperand;\n    case ComparisonOperators.LTE:\n      return leftOperand <= rightOperand;\n    case ComparisonOperators.GT:\n      return leftOperand > rightOperand;\n    case ComparisonOperators.GTE:\n      return leftOperand >= rightOperand;\n  }\n};\n\nconst compoundBooleanProcessor = (operator: CompoundOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case CompoundOperators.AND:\n      return leftOperand && rightOperand;\n    case CompoundOperators.OR:\n      return leftOperand || rightOperand;\n  }\n};\n\nconst booleanConfigProcessor = (booleanConfig: BooleanConfig, rootState, selfValue?: any): boolean => {\n  const { type: operationType } = booleanConfig;\n  switch (operationType) {\n    case OperationType.ATOMIC: {\n      const leftOperand = processValue(booleanConfig.leftOperand as string, rootState, selfValue);\n      const rightOperand = processValue(booleanConfig.rightOperand as string, rootState, selfValue);\n      return atomicBooleanProcessor(booleanConfig.operator as ComparisonOperators, leftOperand, rightOperand);\n    }\n    case OperationType.COMPOUND: {\n      const leftOperand = booleanConfigProcessor(booleanConfig.leftOperand as BooleanConfig, rootState);\n      const rightOperand = booleanConfigProcessor(booleanConfig.rightOperand as BooleanConfig, rootState);\n      return compoundBooleanProcessor(booleanConfig.operator as CompoundOperators, leftOperand, rightOperand);\n    }\n  }\n};\n\nexport const booleanProcessor = (booleanClause: boolean | BooleanConfig, rootState, selfValue?: any) => {\n  if (typeof booleanClause === \"boolean\") {\n    return booleanClause;\n  }\n  return booleanConfigProcessor(booleanClause as BooleanConfig, rootState, selfValue);\n};\n","export interface ITypeMeta {\n  type: string;\n  meta?: any;\n}\n/** Boolean Configs */\nexport enum ComparisonOperators {\n  EQ = \"=\",\n  NOT_EQ = \"!=\",\n  LT = \"<\",\n  LTE = \"<=\",\n  GT = \">\",\n  GTE = \">=\"\n}\n\nexport enum CompoundOperators {\n  AND = \"&&\",\n  OR = \"||\"\n}\n\nexport enum OperationType {\n  ATOMIC = \"ATOMIC\",\n  COMPOUND = \"COMPOUND\"\n}\n\nexport type BooleanConfig = {\n  type: OperationType;\n  operator: ComparisonOperators | CompoundOperators;\n  leftOperand: string | BooleanConfig;\n  rightOperand: string | BooleanConfig;\n};\n\n/** Boolean Configs */\n\n/** Validator Types */\n\nexport enum ValidationTypes {\n  REQUIRED = \"REQUIRED\",\n  REGEX = \"REGEX\",\n  CUSTOM = \"CUSTOM\",\n  RANGE = \"RANGE\",\n  LENGTH = \"LENGTH\",\n  JSON = \"JSON\"\n}\n\nexport interface IValidationConfig extends ITypeMeta {\n  type: ValidationTypes;\n}\n\n/** Validator Types */\n\nexport type IDataFieldConfig = IDataSetDatasourceConfig | IDataAjaxConfig | IDataAjaxConfig;\n\nexport interface IEventsConfig extends ITypeMeta {\n  type: \"AJAX_CALL\" | \"SET_DATASOURCE\" | \"SET_VALUE\";\n  when?: BooleanConfig;\n}\nexport interface IDataAjaxConfig {\n  type: \"AJAX_CALL\";\n  meta: {\n    endpoint: string;\n    queryParams: {\n      [k: string]: string;\n    };\n    credentials?: \"include\" | \"same-origin\" | \"omit\";\n    fieldId?: string;\n    dataProcessor?: string;\n    fieldIds?: { [k: string]: string };\n  };\n}\n\nexport interface IDataSetValueConfig {\n  type: \"SET_VALUE\";\n  meta: {\n    value: any;\n  };\n}\n\nexport interface IDataSetDatasourceConfig {\n  type: \"SET_DATASOURCE\";\n  meta: {\n    data: any;\n  };\n}\n\nexport interface IConfigNode {\n  id: string;\n  type: string;\n  children?: Array<IConfigNode>;\n  meta?: any;\n  style?: any;\n  show?: boolean | BooleanConfig;\n  validations?: Array<IValidationConfig>;\n  events?: {\n    [eventName: string]: Array<IEventsConfig> | IEventsConfig;\n  };\n  data?: Pick<IDataFieldConfig, keyof IDataFieldConfig>;\n}\n\nexport interface IConfig {\n  page: string;\n  config: IConfigNode;\n}\n\nexport interface IConfigRenderer<ReturnNodeType = any> {\n  readonly config: IConfig;\n  render: () => ReturnNodeType;\n}\n","export * from \"./ReactRenderer\";\n","import React, {\n  createContext,\n  memo,\n  useReducer,\n  createElement,\n  useContext,\n  useEffect,\n  useMemo,\n  Dispatch,\n  forwardRef,\n  useRef,\n  useImperativeHandle\n} from \"react\";\nimport { IConfigRenderer, IConfig, IConfigNode, IValidationConfig } from \"./types\";\nimport { handleEvent } from \"./eventHandling\";\nimport { validator } from \"./validator\";\n\n// import produce from \"immer\";\nimport { booleanProcessor } from \"./booleanProcessor\";\nimport { capitalize } from \"./shared\";\n\nconst getWrapperComponentName = (componentId: string) => `${capitalize(componentId)}MasonWrapper`;\n\n/*\nconst immerReducer = (state, { type, payload }) => {\n  return produce(state, draft => {\n    switch (type) {\n      case \"ADD_ENTRY\":\n        draft[payload.id] = payload.props;\n        break;\n      case \"UPDATE_ENTRY\":\n        draft[payload.id] = { ...state[payload.id], ...payload.props };\n        break;\n      case \"UPDATE_PROP\":\n        {\n          if (!state[payload.id]) {\n            throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n          }\n          draft[payload.id][payload.prop] = payload.value;\n        }\n        break;\n      case \"REPLACE_STATE_VALUES\":\n        for (const [key, val] of Object.entries(payload)) {\n          draft[key][\"value\"] = (val as any).value;\n        }\n        break;\n    }\n  });\n};\n*/\n\nconst reducer = (state, { type, payload }) => {\n  switch (type) {\n    case \"ADD_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: payload.props\n      };\n    case \"UPDATE_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: { ...state[payload.id], ...payload.props }\n      };\n    case \"UPDATE_PROP\": {\n      if (!state[payload.id]) {\n        throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n      }\n      return {\n        ...state,\n        [payload.id]: {\n          ...state[payload.id],\n          [payload.prop]: payload.value\n        }\n      };\n    }\n\n    case \"REPLACE_STATE_VALUES\": {\n      const draft = { ...state };\n      for (const [key, val] of Object.entries(payload)) {\n        draft[key][\"value\"] = (val as any).value;\n      }\n      return draft;\n    }\n\n    default:\n      return state;\n  }\n};\n\ntype IRendererContext = {\n  state: IObject;\n  dispatch: Dispatch<{\n    type: string;\n    payload: any;\n  }>;\n};\n\nconst context = createContext<IRendererContext>(null as any);\n\nconst wrappedDispatch = (\n  dispatch: React.Dispatch<{ type: string; payload: any }>,\n  validations: Array<IValidationConfig> = []\n) => ({ type, payload }) => {\n  if (type === \"UPDATE_PROP\" && payload.prop === \"value\") {\n    const { value, id: fieldId } = payload;\n    const validationErrors = validator(validations, value);\n\n    dispatch({\n      type: \"UPDATE_PROP\",\n      payload: {\n        id: fieldId,\n        prop: \"validations\",\n        value: validationErrors\n      }\n    });\n  }\n  return dispatch({ type, payload });\n};\n\nfunction constructStateFromValue(config: IConfigNode, state, values: Map<string, any>) {\n  const { meta, id, children } = config;\n  if (values && values.get(id)) {\n    state[id] = { ...(state[id] || {}), value: values.get(id) };\n  } else if (meta && typeof meta.value !== \"undefined\") {\n    state[id] = { ...(state[id] || {}), value: meta.value };\n  }\n  if (children) {\n    children.forEach(childConfigNode => constructStateFromValue(childConfigNode, state, values));\n  }\n  return state;\n}\n\n// eslint-disable-next-line react/display-name\nconst RootComponentCore: React.ForwardRefExoticComponent<{ initialState: any }> = forwardRef(\n  ({ children, initialState = {} }, ref) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    useImperativeHandle(\n      ref,\n      () => ({\n        setRootState(config: IConfigNode, val) {\n          const newState = constructStateFromValue(config, { ...state }, val);\n          dispatch({ type: \"REPLACE_STATE_VALUES\", payload: newState });\n        }\n      }),\n      [state]\n    );\n\n    return createElement(\n      context.Provider,\n      {\n        value: {\n          state,\n          dispatch\n        }\n      },\n      children\n    );\n  }\n);\n\nexport const RootComponent: React.NamedExoticComponent<any> = memo(RootComponentCore);\n\ntype IObject = {\n  [k: string]: any;\n};\n\ntype IRendererOptions = {\n  initialValues?: Map<string, any>;\n  dataProcessors?: {\n    [k: string]: (a: any) => any;\n  };\n};\n\n// const eventsSeedValue = {};\n\nexport class ReactConfigRenderer implements IConfigRenderer<React.ReactNode> {\n  private components: Map<string, React.Component> = new Map();\n  readonly config: IConfig;\n  private elementsMap: Map<string, React.ComponentType<any>>;\n  private options: IObject;\n  private currentRootStateSnapshot: IObject;\n  private rootComponentRef: React.MutableRefObject<any> | null;\n  constructor(config: IConfig, elementsMap: Map<string, React.ComponentType<any>>, options?: IRendererOptions) {\n    this.config = config;\n    this.elementsMap = elementsMap;\n    this.options = options || {};\n    this.renderConfigNode = this.renderConfigNode.bind(this);\n    this.currentRootStateSnapshot = {};\n    this.rootComponentRef = null;\n  }\n  renderConfigNode(node: IConfigNode) {\n    const { id, type, meta = {}, data, events = {}, validations, children, style, show } = node;\n    const { dataProcessors = {} } = this.options;\n    // if (this.components.has(id)) return this.components.get(id);\n    const elementComponent = this.elementsMap.get(type);\n    if (!elementComponent) {\n      throw new Error(`No component exists for type ${type}`);\n    }\n    const wrappedComponent: React.MemoExoticComponent<any> & { whyDidYouRender?: boolean } = memo(props => {\n      /** Getting the reducer context as a consumer for reading the state and dispatching actions */\n      const { state: rootState, dispatch } = useContext(context);\n      const rootDispatch = wrappedDispatch(dispatch, validations);\n      this.currentRootStateSnapshot = rootState;\n      /** Creating the event handlers out of the events config */\n      const eventsMap = useMemo(() => {\n        return Object.entries(events).reduce((eventsObj, [eventName, eventConfig]) => {\n          const eventHandler = (event: Event, value?: any) => {\n            /** Executing multiple event handlers in case an array is provided against an event type in config */\n            if (Array.isArray(eventConfig)) {\n              eventConfig.forEach(config => {\n                handleEvent(config, { id, event, dataProcessors, value }, rootDispatch, rootState);\n              });\n            } else {\n              handleEvent(eventConfig, { id, event, dataProcessors, value }, rootDispatch, rootState);\n            }\n          };\n          eventsObj[eventName] = eventHandler;\n          return eventsObj;\n        }, {});\n      }, [events, rootState]);\n\n      /** Storing the component and its props in the rootState on mounting */\n      useEffect(() => {\n        rootDispatch({\n          type: rootState[id] ? \"UPDATE_ENTRY\" : \"ADD_ENTRY\",\n          payload: {\n            id,\n            props: { ...meta, ...props, value: rootState[id] ? rootState[id].value : meta.value }\n          }\n        });\n        /** Checking if data key is provided in the config and setting the datasource on component Mount */\n        if (data) {\n          handleEvent(data, { id, dataProcessors }, rootDispatch, rootState);\n        }\n      }, []);\n\n      /** Constructing the original component by setting its props from the rootState and returning it */\n      const component = React.useMemo(\n        () =>\n          createElement(\n            elementComponent,\n            { ...(rootState[id] ? rootState[id] : { ...meta, ...props }), ...eventsMap },\n            props.children\n          ),\n        [rootState[id], eventsMap]\n      );\n      const showCondition: boolean = show !== undefined ? booleanProcessor(show, rootState) : true;\n      useEffect(() => {\n        /**\n         * Check if the element has been hidden based on the show condition above and\n         * hence reset it's value into the rootState.\n         */\n        if (!showCondition && rootState[id] && typeof rootState[id].value !== \"undefined\") {\n          rootDispatch({\n            type: \"UPDATE_PROP\",\n            payload: {\n              id,\n              prop: \"value\",\n              value: meta.value\n            }\n          });\n        }\n      }, [showCondition]);\n\n      return showCondition ? createElement(\"section\", props, component) : null;\n    });\n    wrappedComponent.displayName = getWrapperComponentName(id);\n    // wrappedComponent.whyDidYouRender = true;\n    const el = createElement(\n      wrappedComponent,\n      { key: id, style, id },\n      ...(children ? children.map(this.renderConfigNode) : [])\n    );\n    // this.components.set(id, el);\n    return el;\n  }\n\n  constructInitialState(config: IConfigNode, initialState) {\n    const { initialValues } = this.options;\n    return constructStateFromValue(config, initialState, initialValues);\n  }\n\n  getCurrentValuesSnapshot() {\n    return Object.entries(this.currentRootStateSnapshot).reduce((acc, [key, val]) => {\n      if (typeof val.value !== \"undefined\") {\n        acc[key] = val.value;\n      }\n      return acc;\n    }, {});\n  }\n\n  public setValue(val) {\n    if (this.rootComponentRef) {\n      this.rootComponentRef.current.setRootState(this.config.config, val);\n    }\n  }\n\n  render() {\n    const { config } = this.config;\n    const initialState = this.constructInitialState(config, {});\n    this.rootComponentRef = useRef();\n    return createElement(RootComponent, { initialState, ref: this.rootComponentRef }, [this.renderConfigNode(config)]);\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","import { IDataAjaxConfig, IDataSetDatasourceConfig, IDataSetValueConfig, IEventsConfig } from \"./types\";\nimport { processValue } from \"./shared\";\nimport { booleanProcessor } from \"./booleanProcessor\";\n\ninterface IOptions {\n  id: string;\n  event?: Event | null;\n  value?: any;\n  dataProcessors: {};\n}\n\nconst formQueryString = (queryParams, rootState, selfValue) =>\n  Object.entries(queryParams)\n    .reduce((acc: Array<string>, [key, value]) => {\n      acc.push(`${key}=${processValue(value as string, rootState, selfValue)}`);\n      return acc;\n    }, [])\n    .join(\"&\");\n\nexport const handleEvent = (\n  eventConfig: IEventsConfig,\n  { id, event = null, dataProcessors, value = undefined }: IOptions,\n  rootDispatch,\n  rootState\n) => {\n  const { type, when } = eventConfig;\n\n  /**\n   * Checking if the when clause/config is passed into the event config, process it by passing through\n   * the boolean processor and stop proceeding if it returns falsy\n   */\n  if (when) {\n    const shouldProceed = booleanProcessor(when, rootState, value);\n    if (shouldProceed === false) {\n      return;\n    }\n  }\n  switch (type) {\n    case \"AJAX_CALL\":\n      {\n        const {\n          endpoint,\n          queryParams,\n          dataProcessor,\n          fieldId,\n          fieldIds,\n          credentials = \"omit\"\n        } = (eventConfig as IDataAjaxConfig).meta;\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"loading\",\n            value: true\n          }\n        });\n\n        fetch(\n          `${endpoint}?${\n            queryParams\n              ? formQueryString(\n                  queryParams,\n                  rootState,\n                  value !== undefined ? value : event ? (event.target as HTMLFormElement).value : null\n                )\n              : \"\"\n          }`,\n          {\n            credentials\n          }\n        )\n          .then(response => {\n            if (response.ok) return response.json();\n            throw response;\n          })\n          .then(result => (dataProcessor && dataProcessors[dataProcessor] ? dataProcessors[dataProcessor](result) : result))\n          .then(result => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n            /** If datasource of multiple elements (usually children) needs to be set, fieldIds needs to be intercepted */\n            if (fieldIds) {\n              for (const [fieldIdTemp, fieldDataProcessor] of Object.entries(fieldIds)) {\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldIdTemp,\n                    prop: \"datasource\",\n                    value: dataProcessors && dataProcessors[fieldDataProcessor] && dataProcessors[fieldDataProcessor](result)\n                  }\n                });\n              }\n            } else {\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"datasource\",\n                  value: result\n                }\n              });\n            }\n          })\n          .catch(e => {\n            if (e instanceof Response) {\n              e.text().then(error => {\n                console.error(`Error while fetching datasource: `, error);\n              });\n            } else {\n              console.error(`Error while fetching datasource: `, e);\n            }\n          });\n      }\n      break;\n    case \"SET_DATASOURCE\":\n      {\n        const { data: dataSource } = (eventConfig as IDataSetDatasourceConfig).meta;\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id,\n            prop: \"datasource\",\n            value: dataSource\n          }\n        });\n      }\n      break;\n    case \"SET_VALUE\":\n      {\n        const { meta } = eventConfig as IDataSetValueConfig;\n        const finalValue =\n          typeof meta !== \"undefined\"\n            ? meta.value\n            : value !== undefined\n            ? value\n            : event\n            ? (event.target as HTMLFormElement).value\n            : null;\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id,\n            prop: \"value\",\n            value: finalValue\n          }\n        });\n      }\n      break;\n    default:\n      throw new Error(\"No valid data type provided in config\");\n  }\n};\n","import { IValidationConfig, ValidationTypes } from \"./types\";\n\nexport const validator = (validations: Array<IValidationConfig> = [], value: any) =>\n  validations.reduce((errors: { [k in ValidationTypes]?: string }, validation: IValidationConfig) => {\n    switch (validation.type) {\n      case ValidationTypes.REQUIRED:\n        {\n          if (value === \"\" || value === null || value === undefined) {\n            errors[ValidationTypes.REQUIRED] = `This field is required`;\n          } else {\n            errors[ValidationTypes.REQUIRED] = \"\";\n          }\n        }\n        break;\n      case \"REGEX\":\n        {\n          const {\n            meta: { pattern }\n          } = validation;\n          if (!new RegExp(pattern).test(value)) {\n            errors[ValidationTypes.REGEX] = `Field value doesn't match the pattern`;\n          } else {\n            errors[ValidationTypes.REGEX] = \"\";\n          }\n        }\n        break;\n      case \"LENGTH\":\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (value.length < min) {\n            errors[ValidationTypes.LENGTH] = `Minimum length of ${min} is needed`;\n          } else if (value.length > max) {\n            errors[ValidationTypes.LENGTH] = `Maximum length of ${max} is allowed`;\n          } else {\n            errors[ValidationTypes.LENGTH] = \"\";\n          }\n        }\n        break;\n      case \"RANGE\":\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (!(value > min && value < max)) {\n            errors[ValidationTypes.RANGE] = `The value should be in the range of ${min} and ${max}`;\n          } else {\n            errors[ValidationTypes.RANGE] = \"\";\n          }\n        }\n        break;\n    }\n    return errors;\n  }, {});\n"],"sourceRoot":""}