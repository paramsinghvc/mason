{"version":3,"sources":["webpack://mason/webpack/universalModuleDefinition","webpack://mason/webpack/bootstrap","webpack://mason/./src/shared.ts","webpack://mason/./src/booleanProcessor.ts","webpack://mason/./src/types.ts","webpack://mason/./src/index.ts","webpack://mason/./src/ReactRenderer.ts","webpack://mason/external \"react\"","webpack://mason/./src/eventHandling.ts","webpack://mason/./src/validator.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__5__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","INTERPOLATION_REGEX","processValue","rootState","selfValue","test","matchedResults","match","interpolatedValue","forEach","matchedResult","fullInterpolatedText","fieldId","processedValue","replace","JSON","stringify","capitalize","str","charAt","toUpperCase","slice","booleanConfigProcessor","booleanConfig","type","OperationType","ATOMIC","leftOperand","rightOperand","operator","ComparisonOperators","EQ","NOT_EQ","LT","LTE","GT","GTE","atomicBooleanProcessor","COMPOUND","CompoundOperators","AND","OR","compoundBooleanProcessor","booleanProcessor","booleanClause","ValidationTypes","createContext","React","memo","useReducer","createElement","useContext","useEffect","useMemo","forwardRef","useRef","useImperativeHandle","reducer","state","payload","id","props","Error","prop","draft","entries","val","context","constructStateFromValue","config","values","Array","isArray","childConfigNode","meta","children","initialValue","RootComponentCore","ref","initialState","instance","setRootState","newState","hasErrors","some","validations","onErrorStateChange","options","isPristine","checkIfValuesPristine","isInvalid","determineValidationStatus","isValid","reduce","acc","configNode","validationErrors","validator","Boolean","dispatch","action","Provider","RootComponent","ReactConfigRenderer","elementsMap","components","Map","this","renderConfigNode","currentRootStateSnapshot","rootComponentRef","node","data","events","style","show","disabled","dataProcessors","onStateChange","resolvers","elementComponent","componentId","wrappedComponent","rootDispatch","isValuedBeingUpdated","errors","wrappedDispatch","eventsMap","eventsObj","eventName","eventConfig","event","handleEvent","disabledEvaluated","evaluateDisabledClause","component","showCondition","undefined","displayName","map","initialValues","getValuesFromState","current","constructInitialState","when","endpoint","queryParams","dataProcessor","fieldIds","credentials","error","fetch","push","join","formQueryString","target","then","response","ok","json","result","fieldIdTemp","fieldDataProcessor","e","Response","text","console","message","dataSource","finalValue","validation","REQUIRED","pattern","RegExp","REGEX","min","max","length","LENGTH","RANGE"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mason\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"mason\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__5__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const INTERPOLATION_REGEX = /(<%[^%>]+%>)/g;\n\nexport const processValue = (value: string, rootState: { [k: string]: any }, selfValue?: string): string => {\n  const isInterpolated = INTERPOLATION_REGEX.test(value);\n  if (isInterpolated) {\n    /**\n     * To match the interpolations repetitively\n     * \"foo<%bar%>baz<%bax%>lorem<%ipsum%>dolor\".match(/(<%[^%>]+%>)/g)\n     *  => [\"<%bar%>\", \"<%bax%>\", \"<%ipsum%>\"]\n     */\n    const matchedResults = value.match(INTERPOLATION_REGEX);\n    let interpolatedValue = value;\n    if (matchedResults) {\n      matchedResults.forEach(matchedResult => {\n        /**\n         * For each of the interpolations matched, the inner valuable text needs to be extracted\n         * and processed for finding corresponding value against the field id in the rootState or self\n         * eventually replacing the interpolation with the processed value\n         * \"<%foo%>\".match(/^<%([^%>]+)%>$/)\n         * => [\"<%foo%>\", \"foo\", index: 0, input: \"<%foo%>\", groups: undefined]\n         */\n        const extractIdMatch = matchedResult.match(/^<%([^%>]+)%>$/);\n        const [fullInterpolatedText, fieldId] = extractIdMatch || [\"\", \"\"];\n        const processedValue = fieldId === \"SELF\" ? selfValue : rootState[fieldId] && rootState[fieldId].value;\n        interpolatedValue = interpolatedValue.replace(\n          fullInterpolatedText,\n          typeof processedValue !== \"string\" ? JSON.stringify(processedValue) : processedValue\n        );\n      });\n    }\n    return interpolatedValue;\n  }\n  return typeof value !== \"string\" ? JSON.stringify(value) : value;\n};\n\nexport const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n","import { processValue } from \"./shared\";\nimport { ComparisonOperators, CompoundOperators, BooleanConfig, OperationType } from \"./types\";\n\nconst atomicBooleanProcessor = (operator: ComparisonOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case ComparisonOperators.EQ:\n      return leftOperand === rightOperand;\n    case ComparisonOperators.NOT_EQ:\n      return leftOperand !== rightOperand;\n    case ComparisonOperators.LT:\n      return leftOperand < rightOperand;\n    case ComparisonOperators.LTE:\n      return leftOperand <= rightOperand;\n    case ComparisonOperators.GT:\n      return leftOperand > rightOperand;\n    case ComparisonOperators.GTE:\n      return leftOperand >= rightOperand;\n  }\n};\n\nconst compoundBooleanProcessor = (operator: CompoundOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case CompoundOperators.AND:\n      return leftOperand && rightOperand;\n    case CompoundOperators.OR:\n      return leftOperand || rightOperand;\n  }\n};\n\nconst booleanConfigProcessor = (booleanConfig: BooleanConfig, rootState, selfValue?: any): boolean => {\n  const { type: operationType } = booleanConfig;\n  switch (operationType) {\n    case OperationType.ATOMIC: {\n      const leftOperand = processValue(booleanConfig.leftOperand as string, rootState, selfValue);\n      const rightOperand = processValue(booleanConfig.rightOperand as string, rootState, selfValue);\n      return atomicBooleanProcessor(booleanConfig.operator as ComparisonOperators, leftOperand, rightOperand);\n    }\n    case OperationType.COMPOUND: {\n      const leftOperand = booleanConfigProcessor(booleanConfig.leftOperand as BooleanConfig, rootState);\n      const rightOperand = booleanConfigProcessor(booleanConfig.rightOperand as BooleanConfig, rootState);\n      return compoundBooleanProcessor(booleanConfig.operator as CompoundOperators, leftOperand, rightOperand);\n    }\n  }\n};\n\nexport const booleanProcessor = (booleanClause: boolean | BooleanConfig, rootState, selfValue?: any) => {\n  if (typeof booleanClause === \"boolean\") {\n    return booleanClause;\n  }\n  return booleanConfigProcessor(booleanClause as BooleanConfig, rootState, selfValue);\n};\n","export interface ITypeMeta {\n  type: string;\n  meta?: any;\n}\n/** Boolean Configs */\nexport enum ComparisonOperators {\n  EQ = \"=\",\n  NOT_EQ = \"!=\",\n  LT = \"<\",\n  LTE = \"<=\",\n  GT = \">\",\n  GTE = \">=\"\n}\n\nexport enum CompoundOperators {\n  AND = \"&&\",\n  OR = \"||\"\n}\n\nexport enum OperationType {\n  ATOMIC = \"ATOMIC\",\n  COMPOUND = \"COMPOUND\"\n}\n\nexport type ConditionalConfig = {\n  type: OperationType;\n  operator: ComparisonOperators | CompoundOperators;\n  leftOperand: string | ConditionalConfig;\n  rightOperand: string | ConditionalConfig;\n};\n\nexport type BooleanConfig = ConditionalConfig;\nexport type DisabledConfig = ConditionalConfig;\n\n/** Boolean Configs */\n\n/** Validator Types */\n\nexport enum ValidationTypes {\n  REQUIRED = \"REQUIRED\",\n  REGEX = \"REGEX\",\n  CUSTOM = \"CUSTOM\",\n  RANGE = \"RANGE\",\n  LENGTH = \"LENGTH\",\n  JSON = \"JSON\"\n}\n\nexport interface IValidationConfig extends ITypeMeta {\n  type: ValidationTypes;\n}\n\n/** Validator Types */\n\nexport type IDataFieldConfig = IDataSetDatasourceConfig | IDataAjaxConfig | IDataAjaxConfig;\n\nexport interface IEventsConfig extends ITypeMeta {\n  type: \"AJAX_CALL\" | \"SET_DATASOURCE\" | \"SET_VALUE\" | \"CUSTOM\";\n  when?: BooleanConfig;\n}\nexport interface IDataAjaxConfig {\n  type: \"AJAX_CALL\";\n  meta: {\n    endpoint: string;\n    queryParams: {\n      [k: string]: string;\n    };\n    credentials?: \"include\" | \"same-origin\" | \"omit\";\n    fieldId?: string;\n    dataProcessor?: string;\n    fieldIds?: { [k: string]: string };\n  };\n}\n\nexport interface IDataSetValueConfig {\n  type: \"SET_VALUE\";\n  meta: {\n    value: any;\n    fieldId?: string;\n  };\n}\n\nexport interface IDataSetDatasourceConfig {\n  type: \"SET_DATASOURCE\";\n  meta: {\n    data: any;\n    fieldId?: string;\n  };\n}\n\nexport interface ICustomHandlerConfig {\n  type: \"CUSTOM\";\n  meta: {\n    name: string;\n  };\n}\n\nexport interface IConfigNode {\n  id: string;\n  type: string;\n  children?: Array<IConfigNode>;\n  meta?: any;\n  style?: any;\n  show?: boolean | BooleanConfig;\n  disabled?: boolean | DisabledConfig | ICustomHandlerConfig;\n  validations?: Array<IValidationConfig>;\n  events?: {\n    [eventName: string]: Array<IEventsConfig> | IEventsConfig;\n  };\n  data?: Pick<IDataFieldConfig, keyof IDataFieldConfig>;\n}\n\nexport interface IConfig {\n  page: string;\n  config: IConfigNode | Array<IConfigNode>;\n}\n\nexport interface IConfigRenderer<ReturnNodeType = any> {\n  readonly config: IConfig;\n  render: () => ReturnNodeType;\n}\n","export * from \"./ReactRenderer\";\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport { IConfigRenderer, IConfig, IConfigNode, IValidationConfig, DisabledConfig, ICustomHandlerConfig } from \"./types\";\nimport { handleEvent } from \"./eventHandling\";\nimport { validator } from \"./validator\";\n\n// import produce from \"immer\";\nimport { booleanProcessor } from \"./booleanProcessor\";\nimport { capitalize } from \"./shared\";\n\nconst {\n  createContext,\n  memo,\n  useReducer,\n  createElement,\n  useContext,\n  useEffect,\n  useMemo,\n  forwardRef,\n  useRef,\n  useImperativeHandle\n} = React;\n\nconst getWrapperComponentName = (componentId: string) => `${capitalize(componentId)}MasonWrapper`;\n\nexport type ActionType = {\n  type: string;\n  payload: any;\n};\n\n/*\nconst immerReducer = (state, { type, payload }) => {\n  return produce(state, draft => {\n    switch (type) {\n      case \"ADD_ENTRY\":\n        draft[payload.id] = payload.props;\n        break;\n      case \"UPDATE_ENTRY\":\n        draft[payload.id] = { ...state[payload.id], ...payload.props };\n        break;\n      case \"UPDATE_PROP\":\n        {\n          if (!state[payload.id]) {\n            throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n          }\n          draft[payload.id][payload.prop] = payload.value;\n        }\n        break;\n      case \"REPLACE_STATE_VALUES\":\n        for (const [key, val] of Object.entries(payload)) {\n          draft[key][\"value\"] = (val as any).value;\n        }\n        break;\n    }\n  });\n};\n*/\n\nconst reducer = (state, { type, payload }) => {\n  switch (type) {\n    case \"ADD_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: payload.props\n      };\n    case \"UPDATE_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: { ...state[payload.id], ...payload.props }\n      };\n    case \"UPDATE_PROP\": {\n      if (!state[payload.id]) {\n        throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n      }\n      return {\n        ...state,\n        [payload.id]: {\n          ...state[payload.id],\n          [payload.prop]: payload.value\n        }\n      };\n    }\n\n    case \"REPLACE_STATE_VALUES\": {\n      const draft = { ...state };\n      for (const [key, val] of Object.entries(payload)) {\n        draft[key][\"value\"] = (val as any).value;\n      }\n      return draft;\n    }\n\n    default:\n      return state;\n  }\n};\n\nexport type IRendererOptions = {\n  initialValues?: Map<string, any>;\n  dataProcessors?: {\n    [k: string]: (a: any) => any;\n  };\n  resolvers?: {\n    [k: string]: (a: any) => any;\n  };\n  onStateChange?: (state: { [k: string]: any }) => void;\n  onErrorStateChange?: (hasErrors: boolean) => void;\n};\n\ntype IRendererContext = {\n  state: IObject;\n  dispatch: React.Dispatch<{\n    type: string;\n    payload: any;\n  }>;\n};\n\nconst context = createContext<IRendererContext>(null as any);\n\nconst wrappedDispatch = (\n  dispatch: React.Dispatch<ActionType>,\n  validations: Array<IValidationConfig> = [],\n  options?: { onStateChange?: IRendererOptions[\"onStateChange\"] }\n) => ({ type, payload }) => {\n  const isValuedBeingUpdated = type === \"UPDATE_PROP\" && payload.prop === \"value\";\n  if (isValuedBeingUpdated) {\n    const { value, id: fieldId } = payload;\n    const validationErrors = validator(validations, value);\n    const hasErrors = Object.values(validationErrors).some(Boolean);\n    dispatch({\n      type: \"UPDATE_PROP\",\n      payload: {\n        id: fieldId,\n        prop: \"validations\",\n        value: { hasErrors, errors: validationErrors }\n      }\n    });\n  }\n  const state = dispatch({ type, payload });\n  if (options && options.onStateChange && isValuedBeingUpdated) {\n    options.onStateChange(reducer(state, { type, payload }));\n  }\n};\n\nfunction constructStateFromValue(config: IConfigNode | Array<IConfigNode>, state, values: Map<string, any>) {\n  if (Array.isArray(config)) {\n    config.forEach(childConfigNode => constructStateFromValue(childConfigNode, state, values));\n    return state;\n  }\n  const { meta, id, children } = config;\n  if (values && values.get(id)) {\n    state[id] = { ...(state[id] || {}), value: values.get(id), initialValue: values.get(id) };\n  } else if (meta && typeof meta.value !== \"undefined\") {\n    state[id] = { ...(state[id] || {}), value: meta.value, initialValue: meta.value };\n  }\n  // if (validations && state[id]) {\n  //   const validationErrors = validator(validations, state[id].value);\n  //   const hasErrors = Object.values(validationErrors).some(Boolean);\n  //   state[id][\"isValid\"] = hasErrors;\n  // }\n  if (children) {\n    children.forEach(childConfigNode => constructStateFromValue(childConfigNode, state, values));\n  }\n  return state;\n}\n\nfunction determineValidationStatus(config: IConfigNode | IConfigNode[], state: IObject, isValid: boolean) {\n  if (Array.isArray(config)) {\n    return config.reduce(\n      (acc: boolean, configNode: IConfigNode) => acc && determineValidationStatus(configNode, state, isValid),\n      isValid\n    );\n  }\n  if (config.validations) {\n    const validationErrors = validator(config.validations, state[config.id].value);\n    const hasErrors = Object.values(validationErrors).some(Boolean);\n    if (hasErrors) return false;\n  }\n  if (config.children) {\n    return determineValidationStatus(config.children, state, isValid);\n  }\n  return true;\n}\n\nconst RootComponentCore = forwardRef<any, { initialState: IObject; instance: ReactConfigRenderer }>(\n  ({ children, initialState = {}, instance }, ref) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        setRootState(config: IConfigNode, val) {\n          const newState = constructStateFromValue(config, { ...state }, val);\n          dispatch({ type: \"REPLACE_STATE_VALUES\", payload: newState });\n        }\n      }),\n      [state]\n    );\n\n    /* Check if any of the current state value hasErrors. And set the root Renderer instance value accordingly */\n    const hasErrors = Object.values(state).some(({ validations }) => validations && validations.hasErrors);\n    if (instance.hasErrors !== hasErrors) {\n      const { onErrorStateChange } = instance.options;\n      onErrorStateChange && onErrorStateChange(hasErrors);\n      instance.hasErrors = hasErrors;\n    }\n\n    /* Check if any of the current state value have been changed and set the pristine flag on the Renderer instance */\n    instance.isPristine = instance.checkIfValuesPristine(state);\n\n    /** A silent flag to check the validation status of the whole form in general by executing validators of\n     * each config node against its corresponding value in the state. */\n    instance.isInvalid = !determineValidationStatus(instance.config.config, state, true);\n\n    const props = {\n      value: {\n        state,\n        dispatch: (action: ActionType) => {\n          dispatch(action);\n          return state;\n        }\n      }\n    };\n    return createElement(context.Provider, props, children);\n  }\n);\n\nexport const RootComponent = memo(RootComponentCore);\n\ntype IObject = {\n  [k: string]: any;\n};\n\n// const eventsSeedValue = {};\n\nconst evaluateDisabledClause = (\n  disabled: boolean | DisabledConfig | ICustomHandlerConfig,\n  { rootState, resolvers, instance }\n) => {\n  if (typeof disabled !== \"undefined\") {\n    if (typeof disabled === \"boolean\") return disabled;\n    if (disabled.type) {\n      if (disabled.type === \"CUSTOM\") {\n        const { meta } = disabled as ICustomHandlerConfig;\n        if (resolvers && resolvers[meta.name]) {\n          return resolvers[meta.name](instance);\n        }\n      }\n      return booleanProcessor(disabled as DisabledConfig, rootState);\n    }\n  }\n};\n\nexport class ReactConfigRenderer implements IConfigRenderer<React.ReactNode> {\n  private components: Map<string, React.Component> = new Map();\n  readonly config: IConfig;\n  private elementsMap: Map<string, React.ComponentType<any>>;\n  public options: IRendererOptions;\n  private currentRootStateSnapshot: IObject;\n  private rootComponentRef: React.MutableRefObject<any> | null;\n  public hasErrors = false;\n  public isPristine = true;\n  public isInvalid = false;\n  constructor(config: IConfig, elementsMap: Map<string, React.ComponentType<any>>, options?: IRendererOptions) {\n    this.config = config;\n    this.elementsMap = elementsMap;\n    this.options = options || {};\n    this.renderConfigNode = this.renderConfigNode.bind(this);\n    this.currentRootStateSnapshot = {};\n    this.rootComponentRef = null;\n  }\n  renderConfigNode(node: IConfigNode) {\n    const { id, type, meta = {}, data, events = {}, validations, children, style, show, disabled } = node;\n    const { dataProcessors = {}, onStateChange, resolvers } = this.options;\n\n    const elementComponent = this.elementsMap.get(type);\n    if (!elementComponent) {\n      throw new Error(`No component exists for type ${type}`);\n    }\n    const wrappedComponent: React.MemoExoticComponent<any> & { whyDidYouRender?: boolean } = memo(props => {\n      /** Getting the reducer context as a consumer for reading the state and dispatching actions */\n      const { state: rootState, dispatch } = useContext(context);\n\n      const rootDispatch = wrappedDispatch(dispatch, validations, { onStateChange });\n      this.currentRootStateSnapshot = rootState;\n\n      /** Creating the event handlers out of the events config */\n      const eventsMap = useMemo(() => {\n        return Object.entries(events).reduce((eventsObj, [eventName, eventConfig]) => {\n          const eventHandler = (event: Event, value?: any) => {\n            /** Executing multiple event handlers in case an array is provided against an event type in config */\n            if (Array.isArray(eventConfig)) {\n              eventConfig.forEach(config => {\n                handleEvent(config, { id, event, dataProcessors, value, resolvers }, rootDispatch, rootState);\n              });\n            } else {\n              handleEvent(eventConfig, { id, event, dataProcessors, value, resolvers }, rootDispatch, rootState);\n            }\n          };\n          eventsObj[eventName] = eventHandler;\n          return eventsObj;\n        }, {});\n      }, [events, rootState, rootDispatch]);\n\n      /** Storing the component and its props in the rootState on mounting */\n      useEffect(() => {\n        rootDispatch({\n          type: rootState[id] ? \"UPDATE_ENTRY\" : \"ADD_ENTRY\",\n          payload: {\n            id,\n            props: { ...meta, ...props, value: rootState[id] ? rootState[id].value : meta.value }\n          }\n        });\n        /** Checking if data key is provided in the config and setting the datasource on component Mount */\n        if (data) {\n          handleEvent(data, { id, dataProcessors, resolvers }, rootDispatch, rootState);\n        }\n      }, []);\n\n      const disabledEvaluated = evaluateDisabledClause(disabled, { rootState, resolvers, instance: this });\n\n      /** Constructing the original component by setting its props from the rootState and returning it */\n      const component = React.useMemo(\n        () =>\n          createElement(\n            elementComponent,\n            { ...(rootState[id] ? rootState[id] : { ...meta, ...props }), disabled: disabledEvaluated, ...eventsMap },\n            props.children\n          ),\n        [rootState[id], eventsMap, props.children]\n      );\n      const showCondition: boolean = show !== undefined ? booleanProcessor(show, rootState) : true;\n      useEffect(() => {\n        /**\n         * Check if the element has been hidden based on the show condition above and\n         * hence reset it's value into the rootState.\n         */\n        if (!showCondition && rootState[id] && typeof rootState[id].value !== \"undefined\") {\n          rootDispatch({\n            type: \"UPDATE_PROP\",\n            payload: {\n              id,\n              prop: \"value\",\n              value: meta.value\n            }\n          });\n        }\n      }, [showCondition]);\n\n      return showCondition ? createElement(\"section\", props, component) : null;\n    });\n    wrappedComponent.displayName = getWrapperComponentName(id);\n    // wrappedComponent.whyDidYouRender = true;\n    const el = createElement(\n      wrappedComponent,\n      { key: id, style, id },\n      ...(children ? children.map(this.renderConfigNode) : [])\n    );\n    // this.components.set(id, el);\n    return el;\n  }\n\n  checkIfValuesPristine(rootState: IObject) {\n    return Object.values(rootState).reduce((acc, { value, initialValue }) => {\n      if (typeof initialValue === \"undefined\") return acc && !value;\n      return acc && JSON.stringify(initialValue) === JSON.stringify(value);\n    }, true);\n  }\n\n  constructInitialState(config: IConfigNode | Array<IConfigNode>, initialState) {\n    const { initialValues } = this.options;\n    return constructStateFromValue(config, initialState, initialValues);\n  }\n\n  getValuesFromState(state: IObject) {\n    return Object.entries(state).reduce((acc, [key, val]) => {\n      if (typeof val.value !== \"undefined\") {\n        acc[key] = val.value;\n      }\n      return acc;\n    }, {});\n  }\n\n  getCurrentValuesSnapshot() {\n    return this.getValuesFromState(this.currentRootStateSnapshot);\n  }\n\n  public setValue(val) {\n    if (this.rootComponentRef) {\n      this.rootComponentRef.current.setRootState(this.config.config, val);\n    }\n  }\n\n  render() {\n    return memo(() => {\n      const { config } = this.config;\n      const initialState = this.constructInitialState(config, {});\n      this.rootComponentRef = useRef();\n      return createElement(\n        RootComponent,\n        { initialState, ref: this.rootComponentRef, instance: this },\n        Array.isArray(config) ? config.map(this.renderConfigNode) : [this.renderConfigNode(config)]\n      );\n    });\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","import {\n  IDataAjaxConfig,\n  IDataSetDatasourceConfig,\n  IDataSetValueConfig,\n  IEventsConfig,\n  ICustomHandlerConfig\n} from \"./types\";\nimport { processValue } from \"./shared\";\nimport { booleanProcessor } from \"./booleanProcessor\";\n\ninterface IOptions {\n  id: string;\n  event?: Event | null;\n  value?: any;\n  dataProcessors: {};\n  resolvers: {};\n}\n\nconst formQueryString = (queryParams, rootState, selfValue) =>\n  Object.entries(queryParams)\n    .reduce((acc: Array<string>, [key, value]) => {\n      acc.push(`${key}=${processValue(value as string, rootState, selfValue)}`);\n      return acc;\n    }, [])\n    .join(\"&\");\n\nexport const handleEvent = (\n  eventConfig: IEventsConfig,\n  { id, event = null, dataProcessors, value = undefined, resolvers }: IOptions,\n  rootDispatch,\n  rootState\n) => {\n  const { type, when } = eventConfig;\n\n  /**\n   * Checking if the when clause/config is passed into the event config, process it by passing through\n   * the boolean processor and stop proceeding if it returns falsy\n   */\n  if (when) {\n    const shouldProceed = booleanProcessor(when, rootState, value);\n    if (shouldProceed === false) {\n      return;\n    }\n  }\n  switch (type) {\n    case \"AJAX_CALL\":\n      {\n        const {\n          endpoint,\n          queryParams,\n          dataProcessor,\n          fieldId,\n          fieldIds,\n          credentials = \"omit\"\n        } = (eventConfig as IDataAjaxConfig).meta;\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"loading\",\n            value: true\n          }\n        });\n\n        if (rootState[fieldId || id] && rootState[fieldId || id].error) {\n          rootDispatch({\n            type: \"UPDATE_PROP\",\n            payload: {\n              id: fieldId || id,\n              prop: \"error\",\n              value: null\n            }\n          });\n        }\n\n        fetch(\n          `${endpoint}?${\n            queryParams\n              ? formQueryString(\n                  queryParams,\n                  rootState,\n                  value !== undefined ? value : event ? (event.target as HTMLFormElement).value : null\n                )\n              : \"\"\n          }`,\n          {\n            credentials\n          }\n        )\n          .then(response => {\n            if (response.ok) return response.json();\n            throw response;\n          })\n          .then(result => (dataProcessor && dataProcessors[dataProcessor] ? dataProcessors[dataProcessor](result) : result))\n          .then(result => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n            /** If datasource of multiple elements (usually children) needs to be set, fieldIds needs to be intercepted */\n            if (fieldIds) {\n              for (const [fieldIdTemp, fieldDataProcessor] of Object.entries(fieldIds)) {\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldIdTemp,\n                    prop: \"datasource\",\n                    value: dataProcessors && dataProcessors[fieldDataProcessor] && dataProcessors[fieldDataProcessor](result)\n                  }\n                });\n              }\n            } else {\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"datasource\",\n                  value: result\n                }\n              });\n            }\n          })\n          .catch(e => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n\n            if (e instanceof Response) {\n              e.text().then(error => {\n                console.error(`Error while fetching datasource: `, error);\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldId || id,\n                    prop: \"error\",\n                    value: error\n                  }\n                });\n              });\n            } else {\n              console.error(`Error while fetching datasource: `, e);\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"error\",\n                  value: (e as TypeError).message\n                }\n              });\n            }\n          });\n      }\n      break;\n    case \"SET_DATASOURCE\":\n      {\n        const { data: dataSource, fieldId } = (eventConfig as IDataSetDatasourceConfig).meta;\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"datasource\",\n            value: dataSource\n          }\n        });\n      }\n      break;\n    case \"SET_VALUE\":\n      {\n        const { meta } = eventConfig as IDataSetValueConfig;\n        let finalValue = null;\n        if (typeof meta !== \"undefined\" && meta.value) {\n          finalValue = meta.value;\n        } else if (typeof value !== \"undefined\") {\n          finalValue = value;\n        } else {\n          finalValue = event && (event.target as HTMLFormElement).value;\n        }\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: (meta && meta.fieldId) || id,\n            prop: \"value\",\n            value: finalValue\n          }\n        });\n      }\n      break;\n    case \"CUSTOM\":\n      {\n        const { meta } = eventConfig as ICustomHandlerConfig;\n        if (resolvers && resolvers[meta.name]) {\n          resolvers[meta.name]({ event, value, id });\n        }\n      }\n      break;\n    default:\n      throw new Error(\"No valid data type provided in config\");\n  }\n};\n","import { IValidationConfig, ValidationTypes } from \"./types\";\n\nexport const validator = (validations: Array<IValidationConfig> = [], value: any) =>\n  validations.reduce((errors: { [k in ValidationTypes]?: string }, validation: IValidationConfig) => {\n    switch (validation.type) {\n      case ValidationTypes.REQUIRED:\n        {\n          if (value === \"\" || value === null || value === undefined) {\n            errors[ValidationTypes.REQUIRED] = `This field is required`;\n          } else {\n            errors[ValidationTypes.REQUIRED] = \"\";\n          }\n        }\n        break;\n      case \"REGEX\":\n        {\n          const {\n            meta: { pattern }\n          } = validation;\n          if (!new RegExp(pattern).test(value)) {\n            errors[ValidationTypes.REGEX] = `Field value doesn't match the pattern`;\n          } else {\n            errors[ValidationTypes.REGEX] = \"\";\n          }\n        }\n        break;\n      case \"LENGTH\":\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (value.length < min) {\n            errors[ValidationTypes.LENGTH] = `Minimum length of ${min} is needed`;\n          } else if (value.length > max) {\n            errors[ValidationTypes.LENGTH] = `Maximum length of ${max} is allowed`;\n          } else {\n            errors[ValidationTypes.LENGTH] = \"\";\n          }\n        }\n        break;\n      case \"RANGE\":\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (!(value > min && value < max)) {\n            errors[ValidationTypes.RANGE] = `The value should be in the range of ${min} and ${max}`;\n          } else {\n            errors[ValidationTypes.RANGE] = \"\";\n          }\n        }\n        break;\n    }\n    return errors;\n  }, {});\n"],"sourceRoot":""}