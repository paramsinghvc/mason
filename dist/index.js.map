{"version":3,"sources":["webpack://mason/webpack/universalModuleDefinition","webpack://mason/webpack/bootstrap","webpack://mason/./src/shared.ts","webpack://mason/./src/booleanProcessor.ts","webpack://mason/./src/types.ts","webpack://mason/./src/index.ts","webpack://mason/./src/ReactRenderer.ts","webpack://mason/external \"react\"","webpack://mason/./src/eventHandling.ts","webpack://mason/./src/validator.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__5__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","INTERPOLATION_REGEX","processValue","rootState","selfValue","test","matchedResults","match","interpolatedValue","forEach","matchedResult","fullInterpolatedText","fieldId","processedValue","replace","JSON","stringify","capitalize","str","charAt","toUpperCase","slice","booleanConfigProcessor","booleanConfig","type","OperationType","ATOMIC","leftOperand","rightOperand","operator","ComparisonOperators","EQ","NOT_EQ","LT","LTE","GT","GTE","atomicBooleanProcessor","COMPOUND","CompoundOperators","AND","OR","compoundBooleanProcessor","booleanProcessor","booleanClause","ValidationTypes","createContext","React","memo","useReducer","createElement","useContext","useEffect","useMemo","forwardRef","useRef","useImperativeHandle","getWrapperComponentName","componentId","reducer","state","payload","id","props","Error","prop","draft","entries","val","context","constructStateFromValue","config","values","Array","isArray","childConfigNode","meta","children","initialValue","RootComponentCore","ref","initialState","instance","setRootState","newState","hasErrors","some","validations","onErrorStateChange","options","isPristine","checkIfValuesPristine","isInvalid","determineValidationStatus","isValid","reduce","acc","configNode","validationErrors","validator","validators","Boolean","dispatch","action","Provider","RootComponent","ReactConfigRenderer","elementsMap","componentsMap","Map","this","renderConfigNode","currentRootStateSnapshot","rootComponentRef","node","data","events","style","show","disabled","dataProcessors","onStateChange","resolvers","elementComponent","component","wrappedComponent","rootDispatch","isValuedBeingUpdated","errors","wrappedDispatch","eventsMap","eventsObj","eventName","eventConfig","event","handleEvent","disabledEvaluated","evaluateDisabledClause","showCondition","undefined","sectionProps","displayName","has","set","map","initialValues","getValuesFromState","current","constructInitialState","when","endpoint","queryParams","dataProcessor","fieldIds","credentials","error","fetch","push","join","formQueryString","target","then","response","ok","json","result","fieldIdTemp","fieldDataProcessor","e","Response","text","console","message","dataSource","finalValue","validation","REQUIRED","REGEX","pattern","RegExp","LENGTH","min","max","length","RANGE","parse","err","CUSTOM"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mason\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"mason\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__5__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const INTERPOLATION_REGEX = /(<%[^%>]+%>)/g;\n\nexport const processValue = (value: string, rootState: { [k: string]: any }, selfValue?: string): string => {\n  const isInterpolated = INTERPOLATION_REGEX.test(value);\n  if (isInterpolated) {\n    /**\n     * To match the interpolations repetitively\n     * \"foo<%bar%>baz<%bax%>lorem<%ipsum%>dolor\".match(/(<%[^%>]+%>)/g)\n     *  => [\"<%bar%>\", \"<%bax%>\", \"<%ipsum%>\"]\n     */\n    const matchedResults = value.match(INTERPOLATION_REGEX);\n    let interpolatedValue = value;\n    if (matchedResults) {\n      matchedResults.forEach(matchedResult => {\n        /**\n         * For each of the interpolations matched, the inner valuable text needs to be extracted\n         * and processed for finding corresponding value against the field id in the rootState or self\n         * eventually replacing the interpolation with the processed value\n         * \"<%foo%>\".match(/^<%([^%>]+)%>$/)\n         * => [\"<%foo%>\", \"foo\", index: 0, input: \"<%foo%>\", groups: undefined]\n         */\n        const extractIdMatch = matchedResult.match(/^<%([^%>]+)%>$/);\n        const [fullInterpolatedText, fieldId] = extractIdMatch || [\"\", \"\"];\n        const processedValue = fieldId === \"SELF\" ? selfValue : rootState[fieldId] && rootState[fieldId].value;\n        interpolatedValue = interpolatedValue.replace(\n          fullInterpolatedText,\n          typeof processedValue !== \"string\" ? JSON.stringify(processedValue) : processedValue\n        );\n      });\n    }\n    return interpolatedValue;\n  }\n  return typeof value !== \"string\" ? JSON.stringify(value) : value;\n};\n\nexport const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n","import { processValue } from \"./shared\";\nimport { ComparisonOperators, CompoundOperators, BooleanConfig, OperationType, State } from \"./types\";\n\nconst atomicBooleanProcessor = (operator: ComparisonOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case ComparisonOperators.EQ:\n      return leftOperand === rightOperand;\n    case ComparisonOperators.NOT_EQ:\n      return leftOperand !== rightOperand;\n    case ComparisonOperators.LT:\n      return leftOperand < rightOperand;\n    case ComparisonOperators.LTE:\n      return leftOperand <= rightOperand;\n    case ComparisonOperators.GT:\n      return leftOperand > rightOperand;\n    case ComparisonOperators.GTE:\n      return leftOperand >= rightOperand;\n  }\n};\n\nconst compoundBooleanProcessor = (operator: CompoundOperators, leftOperand: any, rightOperand: any): boolean => {\n  switch (operator) {\n    case CompoundOperators.AND:\n      return leftOperand && rightOperand;\n    case CompoundOperators.OR:\n      return leftOperand || rightOperand;\n  }\n};\n\nconst booleanConfigProcessor = (booleanConfig: BooleanConfig, rootState: State, selfValue?: any): boolean => {\n  const { type: operationType } = booleanConfig;\n  switch (operationType) {\n    case OperationType.ATOMIC: {\n      const leftOperand = processValue(booleanConfig.leftOperand as string, rootState, selfValue);\n      const rightOperand = processValue(booleanConfig.rightOperand as string, rootState, selfValue);\n      return atomicBooleanProcessor(booleanConfig.operator as ComparisonOperators, leftOperand, rightOperand);\n    }\n    case OperationType.COMPOUND: {\n      const leftOperand = booleanConfigProcessor(booleanConfig.leftOperand as BooleanConfig, rootState);\n      const rightOperand = booleanConfigProcessor(booleanConfig.rightOperand as BooleanConfig, rootState);\n      return compoundBooleanProcessor(booleanConfig.operator as CompoundOperators, leftOperand, rightOperand);\n    }\n  }\n};\n\nexport const booleanProcessor = (booleanClause: boolean | BooleanConfig, rootState: State, selfValue?: any) => {\n  if (typeof booleanClause === \"boolean\") {\n    return booleanClause;\n  }\n  return booleanConfigProcessor(booleanClause as BooleanConfig, rootState, selfValue);\n};\n","export interface ITypeMeta {\n  type: string;\n  meta?: any;\n}\n/** Boolean Configs */\nexport enum ComparisonOperators {\n  EQ = \"=\",\n  NOT_EQ = \"!=\",\n  LT = \"<\",\n  LTE = \"<=\",\n  GT = \">\",\n  GTE = \">=\"\n}\n\nexport enum CompoundOperators {\n  AND = \"&&\",\n  OR = \"||\"\n}\n\nexport enum OperationType {\n  ATOMIC = \"ATOMIC\",\n  COMPOUND = \"COMPOUND\"\n}\n\nexport type ConditionalConfig = {\n  type: OperationType;\n  operator: ComparisonOperators | CompoundOperators;\n  leftOperand: string | ConditionalConfig;\n  rightOperand: string | ConditionalConfig;\n};\n\nexport type BooleanConfig = ConditionalConfig;\nexport type DisabledConfig = ConditionalConfig;\n\n/** Boolean Configs */\n\n/** Validator Types */\n\nexport enum ValidationTypes {\n  REQUIRED = \"REQUIRED\",\n  REGEX = \"REGEX\",\n  CUSTOM = \"CUSTOM\",\n  RANGE = \"RANGE\",\n  LENGTH = \"LENGTH\",\n  JSON = \"JSON\"\n}\n\nexport interface IValidationConfig extends ITypeMeta {\n  type: ValidationTypes;\n}\n\n/** Validator Types */\n\nexport type IDataFieldConfig = IDataSetDatasourceConfig | IDataAjaxConfig | IDataAjaxConfig;\n\nexport interface IEventsConfig extends ITypeMeta {\n  type: \"AJAX_CALL\" | \"SET_DATASOURCE\" | \"SET_VALUE\" | \"CUSTOM\";\n  when?: BooleanConfig;\n}\nexport interface IDataAjaxConfig {\n  type: \"AJAX_CALL\";\n  meta: {\n    endpoint: string;\n    queryParams: {\n      [k: string]: string;\n    };\n    credentials?: \"include\" | \"same-origin\" | \"omit\";\n    fieldId?: string;\n    dataProcessor?: string;\n    fieldIds?: { [k: string]: string };\n  };\n}\n\nexport interface IDataSetValueConfig {\n  type: \"SET_VALUE\";\n  meta: {\n    value: any;\n    fieldId?: string;\n  };\n}\n\nexport interface IDataSetDatasourceConfig {\n  type: \"SET_DATASOURCE\";\n  meta: {\n    data: any;\n    fieldId?: string;\n  };\n}\n\nexport interface ICustomHandlerConfig {\n  type: \"CUSTOM\";\n  meta: {\n    name: string;\n  };\n}\n\nexport interface IConfigNode {\n  id: string;\n  type: string;\n  children?: Array<IConfigNode>;\n  meta?: any;\n  style?: any;\n  show?: boolean | BooleanConfig;\n  disabled?: boolean | DisabledConfig | ICustomHandlerConfig;\n  validations?: Array<IValidationConfig>;\n  events?: {\n    [eventName: string]: Array<IEventsConfig> | IEventsConfig;\n  };\n  data?: Pick<IDataFieldConfig, keyof IDataFieldConfig>;\n}\n\nexport interface IConfig {\n  page: string;\n  config: IConfigNode | Array<IConfigNode>;\n}\n\nexport interface IConfigRenderer<ReturnNodeType = any> {\n  readonly config: IConfig;\n  render: () => ReturnNodeType;\n}\n\nexport type IObject = {\n  [k: string]: any;\n};\n\nexport type State = {\n  [id: string]: {\n    value: any;\n    initialValue: any;\n    validations?: {\n      hasErrors: boolean;\n      errors: IObject;\n    };\n    [key: string]: any;\n  };\n};\n\nexport type StateReturnableDispatch<A> = (value: A) => State;\n\nexport type ActionType = {\n  type: string;\n  payload: any;\n};\n\nexport type Dispatch = StateReturnableDispatch<ActionType>;\n\nexport type FunctionsMap<T = any, U = any> = {\n  [k: string]: (a: T) => U;\n};\n\nexport type ValidatorFunctionsMap = FunctionsMap<any, string | undefined | null>;\n\nexport type IRendererOptions = {\n  initialValues?: Map<string, any>;\n  dataProcessors?: FunctionsMap;\n  resolvers?: FunctionsMap;\n  validators?: ValidatorFunctionsMap;\n  onStateChange?: (state: State) => void;\n  onErrorStateChange?: (hasErrors: boolean) => void;\n};\n","export * from \"./ReactRenderer\";\n","/* eslint-disable react/display-name */\nimport * as React from \"react\";\nimport {\n  IConfigRenderer,\n  IConfig,\n  IConfigNode,\n  IValidationConfig,\n  DisabledConfig,\n  ICustomHandlerConfig,\n  State,\n  Dispatch,\n  ActionType,\n  IObject,\n  IRendererOptions,\n  FunctionsMap,\n  ValidatorFunctionsMap\n} from \"./types\";\nimport { handleEvent } from \"./eventHandling\";\nimport { validator } from \"./validator\";\n\n// import produce from \"immer\";\nimport { booleanProcessor } from \"./booleanProcessor\";\nimport { capitalize } from \"./shared\";\n\nconst {\n  createContext,\n  memo,\n  useReducer,\n  createElement,\n  useContext,\n  useEffect,\n  useMemo,\n  forwardRef,\n  useRef,\n  useImperativeHandle\n} = React;\n\nconst getWrapperComponentName = (componentId: string) => `${capitalize(componentId)}MasonWrapper`;\n\n/*\nconst immerReducer = (state, { type, payload }) => {\n  return produce(state, draft => {\n    switch (type) {\n      case \"ADD_ENTRY\":\n        draft[payload.id] = payload.props;\n        break;\n      case \"UPDATE_ENTRY\":\n        draft[payload.id] = { ...state[payload.id], ...payload.props };\n        break;\n      case \"UPDATE_PROP\":\n        {\n          if (!state[payload.id]) {\n            throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n          }\n          draft[payload.id][payload.prop] = payload.value;\n        }\n        break;\n      case \"REPLACE_STATE_VALUES\":\n        for (const [key, val] of Object.entries(payload)) {\n          draft[key][\"value\"] = (val as any).value;\n        }\n        break;\n    }\n  });\n};\n*/\n\nconst reducer = (state: State, { type, payload }) => {\n  switch (type) {\n    case \"ADD_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: payload.props\n      };\n    case \"UPDATE_ENTRY\":\n      return {\n        ...state,\n        [payload.id]: { ...state[payload.id], ...payload.props }\n      };\n    case \"UPDATE_PROP\": {\n      if (!state[payload.id]) {\n        throw new Error(`Invalid component id ${payload.id} provided for prop updation`);\n      }\n      return {\n        ...state,\n        [payload.id]: {\n          ...state[payload.id],\n          [payload.prop]: payload.value\n        }\n      };\n    }\n\n    case \"REPLACE_STATE_VALUES\": {\n      const draft = { ...state };\n      for (const [key, val] of Object.entries(payload)) {\n        draft[key][\"value\"] = (val as any).value;\n      }\n      return draft;\n    }\n\n    default:\n      return state;\n  }\n};\n\ntype IRendererContext = {\n  state: State;\n  dispatch: Dispatch;\n};\n\nconst context = createContext<IRendererContext>(null as any);\n\nconst wrappedDispatch = (\n  dispatch: Dispatch,\n  validations: Array<IValidationConfig> = [],\n  options?: {\n    onStateChange?: IRendererOptions[\"onStateChange\"];\n    validators?: ValidatorFunctionsMap;\n  }\n) => ({ type, payload }) => {\n  const isValuedBeingUpdated = type === \"UPDATE_PROP\" && payload.prop === \"value\";\n  if (isValuedBeingUpdated) {\n    const { value, id: fieldId } = payload;\n    const validationErrors = validator(validations, value, { validators: options && options.validators });\n    const hasErrors = Object.values(validationErrors).some(Boolean);\n    dispatch({\n      type: \"UPDATE_PROP\",\n      payload: {\n        id: fieldId,\n        prop: \"validations\",\n        value: { hasErrors, errors: validationErrors }\n      }\n    });\n  }\n  const state = dispatch({ type, payload });\n  if (options && options.onStateChange && isValuedBeingUpdated) {\n    options.onStateChange(reducer(state, { type, payload }));\n  }\n  return state;\n};\n\nfunction constructStateFromValue(config: IConfigNode | Array<IConfigNode>, state: State, values: Map<string, any>) {\n  if (Array.isArray(config)) {\n    config.forEach(childConfigNode => constructStateFromValue(childConfigNode, state, values));\n    return state;\n  }\n  const { meta, id, children } = config;\n  if (values && values.get(id)) {\n    state[id] = { ...(state[id] || {}), value: values.get(id), initialValue: values.get(id) };\n  } else if (meta && typeof meta.value !== \"undefined\") {\n    state[id] = { ...(state[id] || {}), value: meta.value, initialValue: meta.value };\n  }\n  // if (validations && state[id]) {\n  //   const validationErrors = validator(validations, state[id].value);\n  //   const hasErrors = Object.values(validationErrors).some(Boolean);\n  //   state[id][\"isValid\"] = hasErrors;\n  // }\n  if (children) {\n    children.forEach(childConfigNode => constructStateFromValue(childConfigNode, state, values));\n  }\n  return state;\n}\n\nfunction determineValidationStatus(\n  config: IConfigNode | IConfigNode[],\n  state: State,\n  isValid: boolean,\n  options?: { validators?: ValidatorFunctionsMap }\n) {\n  if (Array.isArray(config)) {\n    return config.reduce(\n      (acc: boolean, configNode: IConfigNode) => acc && determineValidationStatus(configNode, state, isValid, options),\n      isValid\n    );\n  }\n  if (config.validations) {\n    const validationErrors = validator(config.validations, state[config.id].value, {\n      validators: options && options.validators\n    });\n    const hasErrors = Object.values(validationErrors).some(Boolean);\n    if (hasErrors) return false;\n  }\n  if (config.children) {\n    return determineValidationStatus(config.children, state, isValid, options);\n  }\n  return true;\n}\n\nconst RootComponentCore = forwardRef<any, { initialState: State; instance: ReactConfigRenderer }>(\n  ({ children, initialState = {}, instance }, ref) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        setRootState(config: IConfigNode, val) {\n          const newState = constructStateFromValue(config, { ...state }, val);\n          dispatch({ type: \"REPLACE_STATE_VALUES\", payload: newState });\n        }\n      }),\n      [state]\n    );\n\n    /* Check if any of the current state value hasErrors. And set the root Renderer instance value accordingly */\n    const hasErrors = Object.values(state).some(({ validations }) => validations && validations.hasErrors);\n    if (instance.hasErrors !== hasErrors) {\n      const { onErrorStateChange } = instance.options;\n      onErrorStateChange && onErrorStateChange(hasErrors);\n      instance.hasErrors = hasErrors;\n    }\n\n    /* Check if any of the current state value have been changed and set the pristine flag on the Renderer instance */\n    instance.isPristine = instance.checkIfValuesPristine(state);\n\n    /** A silent flag to check the validation status of the whole form in general by executing validators of\n     * each config node against its corresponding value in the state. */\n    instance.isInvalid = !determineValidationStatus(instance.config.config, state, true, {\n      validators: instance.options.validators\n    });\n\n    const props = {\n      value: {\n        state,\n        dispatch: (action: ActionType) => {\n          dispatch(action);\n          return state;\n        }\n      }\n    };\n    return createElement(context.Provider, props, children);\n  }\n);\n\nexport const RootComponent = memo(RootComponentCore);\n\n// const eventsSeedValue = {};\n\nconst evaluateDisabledClause = (\n  disabled: boolean | DisabledConfig | ICustomHandlerConfig,\n  { rootState, resolvers, instance }\n) => {\n  if (typeof disabled !== \"undefined\") {\n    if (typeof disabled === \"boolean\") return disabled;\n    if (disabled.type) {\n      if (disabled.type === \"CUSTOM\") {\n        const { meta } = disabled as ICustomHandlerConfig;\n        if (resolvers && resolvers[meta.name]) {\n          return resolvers[meta.name](instance);\n        }\n      }\n      return booleanProcessor(disabled as DisabledConfig, rootState);\n    }\n  }\n};\n\nexport class ReactConfigRenderer implements IConfigRenderer<React.ReactNode> {\n  private componentsMap: Map<string, React.ExoticComponent> = new Map();\n  readonly config: IConfig;\n  private elementsMap: Map<string, React.ComponentType<any>>;\n  public options: IRendererOptions;\n  private currentRootStateSnapshot: State;\n  private rootComponentRef: React.MutableRefObject<any> | null;\n  public hasErrors = false;\n  public isPristine = true;\n  public isInvalid = false;\n  constructor(config: IConfig, elementsMap: Map<string, React.ComponentType<any>>, options?: IRendererOptions) {\n    this.config = config;\n    this.elementsMap = elementsMap;\n    this.options = options || {};\n    this.renderConfigNode = this.renderConfigNode.bind(this);\n    this.currentRootStateSnapshot = {};\n    this.rootComponentRef = null;\n  }\n  renderConfigNode(node: IConfigNode) {\n    const { id, type, meta = {}, data, events = {}, validations, children, style, show, disabled } = node;\n    const { dataProcessors = {}, onStateChange, resolvers, validators } = this.options;\n\n    const elementComponent = this.elementsMap.get(type);\n    if (!elementComponent) {\n      throw new Error(`No component exists for type ${type}`);\n    }\n    const wrappedComponent: React.NamedExoticComponent<{ style: IObject; resolvers: FunctionsMap; id: string }> = memo(\n      props => {\n        /** Getting the reducer context as a consumer for reading the state and dispatching actions */\n        const { state: rootState, dispatch } = useContext(context);\n\n        const rootDispatch = wrappedDispatch(dispatch, validations, { onStateChange, validators });\n        this.currentRootStateSnapshot = rootState;\n\n        /** Creating the event handlers out of the events config */\n        const eventsMap = useMemo(() => {\n          return Object.entries(events).reduce((eventsObj, [eventName, eventConfig]) => {\n            const eventHandler = (event: Event, value?: any) => {\n              /** Executing multiple event handlers in case an array is provided against an event type in config */\n              if (Array.isArray(eventConfig)) {\n                eventConfig.forEach(config => {\n                  handleEvent(\n                    config,\n                    { id, event, dataProcessors, value, resolvers: props.resolvers },\n                    rootDispatch,\n                    rootState\n                  );\n                });\n              } else {\n                handleEvent(\n                  eventConfig,\n                  { id, event, dataProcessors, value, resolvers: props.resolvers },\n                  rootDispatch,\n                  rootState\n                );\n              }\n            };\n            eventsObj[eventName] = eventHandler;\n            return eventsObj;\n          }, {});\n        }, [events, rootState, rootDispatch]);\n\n        /** Storing the component and its props in the rootState on mounting */\n        useEffect(() => {\n          rootDispatch({\n            type: rootState[id] ? \"UPDATE_ENTRY\" : \"ADD_ENTRY\",\n            payload: {\n              id,\n              props: { ...meta, ...props, value: rootState[id] ? rootState[id].value : meta.value }\n            }\n          });\n          /** Checking if data key is provided in the config and setting the datasource on component Mount */\n          if (data) {\n            handleEvent(data, { id, dataProcessors, resolvers: props.resolvers }, rootDispatch, rootState);\n          }\n        }, []);\n\n        const disabledEvaluated = evaluateDisabledClause(disabled, {\n          rootState,\n          resolvers: props.resolvers,\n          instance: this\n        });\n\n        /** Constructing the original component by setting its props from the rootState and returning it */\n        const component = useMemo(\n          () =>\n            createElement(\n              elementComponent,\n              { ...(rootState[id] ? rootState[id] : { ...meta, ...props }), disabled: disabledEvaluated, ...eventsMap },\n              props.children\n            ),\n          [rootState[id], eventsMap, props.children]\n        );\n        const showCondition: boolean = show !== undefined ? booleanProcessor(show, rootState) : true;\n        useEffect(() => {\n          /**\n           * Check if the element has been hidden based on the show condition above and\n           * hence reset it's value into the rootState.\n           */\n          if (!showCondition && rootState[id] && typeof rootState[id].value !== \"undefined\") {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id,\n                prop: \"value\",\n                value: meta.value\n              }\n            });\n          }\n        }, [showCondition]);\n\n        const sectionProps = { ...props };\n        delete sectionProps.resolvers;\n        return showCondition ? createElement(\"section\", sectionProps, component) : null;\n      }\n    );\n    const displayName = getWrapperComponentName(id);\n    let component;\n    if (this.componentsMap.has(displayName)) {\n      component = this.componentsMap.get(displayName);\n    } else {\n      wrappedComponent.displayName = getWrapperComponentName(id);\n      this.componentsMap.set(displayName, wrappedComponent);\n      component = wrappedComponent;\n    }\n    // wrappedComponent.whyDidYouRender = true;\n    const el = createElement(\n      component,\n      { key: id, style, id, resolvers },\n      ...(children ? children.map(this.renderConfigNode) : [])\n    );\n    // this.components.set(id, el);\n    return el;\n  }\n\n  checkIfValuesPristine(rootState: State) {\n    return Object.values(rootState).reduce((acc, { value, initialValue }) => {\n      if (typeof initialValue === \"undefined\") return acc && !value;\n      return acc && JSON.stringify(initialValue) === JSON.stringify(value);\n    }, true);\n  }\n\n  constructInitialState(config: IConfigNode | Array<IConfigNode>, initialState) {\n    const { initialValues } = this.options;\n    return constructStateFromValue(config, initialState, initialValues);\n  }\n\n  getValuesFromState(state: State) {\n    return Object.entries(state).reduce((acc, [key, val]) => {\n      if (typeof val.value !== \"undefined\") {\n        acc[key] = val.value;\n      }\n      return acc;\n    }, {});\n  }\n\n  getCurrentValuesSnapshot() {\n    return this.getValuesFromState(this.currentRootStateSnapshot);\n  }\n\n  public setValue(val) {\n    if (this.rootComponentRef) {\n      this.rootComponentRef.current.setRootState(this.config.config, val);\n    }\n  }\n\n  render() {\n    return memo((props: { resolvers?: FunctionsMap }) => {\n      const { config } = this.config;\n      if (props.resolvers) {\n        this.options.resolvers = props.resolvers;\n      }\n      const initialState = this.constructInitialState(config, {});\n      this.rootComponentRef = useRef();\n      return createElement(\n        RootComponent,\n        { initialState, ref: this.rootComponentRef, instance: this },\n        Array.isArray(config) ? config.map(this.renderConfigNode) : [this.renderConfigNode(config)]\n      );\n    });\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","import {\n  IDataAjaxConfig,\n  IDataSetDatasourceConfig,\n  IDataSetValueConfig,\n  IEventsConfig,\n  ICustomHandlerConfig,\n  State,\n  Dispatch\n} from \"./types\";\nimport { processValue } from \"./shared\";\nimport { booleanProcessor } from \"./booleanProcessor\";\n\ninterface IOptions {\n  id: string;\n  event?: Event | null;\n  value?: any;\n  dataProcessors: {};\n  resolvers: {};\n}\n\nconst formQueryString = (queryParams, rootState: State, selfValue) =>\n  Object.entries(queryParams)\n    .reduce((acc: Array<string>, [key, value]) => {\n      acc.push(`${key}=${processValue(value as string, rootState, selfValue)}`);\n      return acc;\n    }, [])\n    .join(\"&\");\n\nexport const handleEvent = (\n  eventConfig: IEventsConfig,\n  { id, event = null, dataProcessors, value = undefined, resolvers }: IOptions,\n  rootDispatch: Dispatch,\n  rootState: State\n) => {\n  const { type, when } = eventConfig;\n\n  /**\n   * Checking if the when clause/config is passed into the event config, process it by passing through\n   * the boolean processor and stop proceeding if it returns falsy\n   */\n  if (when) {\n    const shouldProceed = booleanProcessor(when, rootState, value);\n    if (shouldProceed === false) {\n      return;\n    }\n  }\n  switch (type) {\n    case \"AJAX_CALL\":\n      {\n        const {\n          endpoint,\n          queryParams,\n          dataProcessor,\n          fieldId,\n          fieldIds,\n          credentials = \"omit\"\n        } = (eventConfig as IDataAjaxConfig).meta;\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"loading\",\n            value: true\n          }\n        });\n\n        if (rootState[fieldId || id] && rootState[fieldId || id].error) {\n          rootDispatch({\n            type: \"UPDATE_PROP\",\n            payload: {\n              id: fieldId || id,\n              prop: \"error\",\n              value: null\n            }\n          });\n        }\n\n        fetch(\n          `${endpoint}?${\n            queryParams\n              ? formQueryString(\n                  queryParams,\n                  rootState,\n                  value !== undefined ? value : event ? (event.target as HTMLFormElement).value : null\n                )\n              : \"\"\n          }`,\n          {\n            credentials\n          }\n        )\n          .then(response => {\n            if (response.ok) return response.json();\n            throw response;\n          })\n          .then(result => (dataProcessor && dataProcessors[dataProcessor] ? dataProcessors[dataProcessor](result) : result))\n          .then(result => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n            /** If datasource of multiple elements (usually children) needs to be set, fieldIds needs to be intercepted */\n            if (fieldIds) {\n              for (const [fieldIdTemp, fieldDataProcessor] of Object.entries(fieldIds)) {\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldIdTemp,\n                    prop: \"datasource\",\n                    value: dataProcessors && dataProcessors[fieldDataProcessor] && dataProcessors[fieldDataProcessor](result)\n                  }\n                });\n              }\n            } else {\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"datasource\",\n                  value: result\n                }\n              });\n            }\n          })\n          .catch(e => {\n            rootDispatch({\n              type: \"UPDATE_PROP\",\n              payload: {\n                id: fieldId || id,\n                prop: \"loading\",\n                value: false\n              }\n            });\n\n            if (e instanceof Response) {\n              e.text().then(error => {\n                console.error(`Error while fetching datasource: `, error);\n                rootDispatch({\n                  type: \"UPDATE_PROP\",\n                  payload: {\n                    id: fieldId || id,\n                    prop: \"error\",\n                    value: error\n                  }\n                });\n              });\n            } else {\n              console.error(`Error while fetching datasource: `, e);\n              rootDispatch({\n                type: \"UPDATE_PROP\",\n                payload: {\n                  id: fieldId || id,\n                  prop: \"error\",\n                  value: (e as TypeError).message\n                }\n              });\n            }\n          });\n      }\n      break;\n    case \"SET_DATASOURCE\":\n      {\n        const { data: dataSource, fieldId } = (eventConfig as IDataSetDatasourceConfig).meta;\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: fieldId || id,\n            prop: \"datasource\",\n            value: dataSource\n          }\n        });\n      }\n      break;\n    case \"SET_VALUE\":\n      {\n        const { meta } = eventConfig as IDataSetValueConfig;\n        let finalValue = null;\n        if (typeof meta !== \"undefined\" && meta.value) {\n          finalValue = meta.value;\n        } else if (typeof value !== \"undefined\") {\n          finalValue = value;\n        } else {\n          finalValue = event && (event.target as HTMLFormElement).value;\n        }\n\n        rootDispatch({\n          type: \"UPDATE_PROP\",\n          payload: {\n            id: (meta && meta.fieldId) || id,\n            prop: \"value\",\n            value: finalValue\n          }\n        });\n      }\n      break;\n    case \"CUSTOM\":\n      {\n        const { meta } = eventConfig as ICustomHandlerConfig;\n        if (resolvers && resolvers[meta.name]) {\n          resolvers[meta.name]({ event, value, id });\n        }\n      }\n      break;\n    default:\n      throw new Error(\"No valid data type provided in config\");\n  }\n};\n","import { IValidationConfig, ValidationTypes, ValidatorFunctionsMap } from \"./types\";\n\nexport const validator = (\n  validations: Array<IValidationConfig> = [],\n  value: any,\n  options?: { validators: ValidatorFunctionsMap }\n) =>\n  validations.reduce((errors: { [k in ValidationTypes]?: string }, validation: IValidationConfig) => {\n    switch (validation.type) {\n      case ValidationTypes.REQUIRED:\n        {\n          if (value === \"\" || value === null || value === undefined) {\n            errors[ValidationTypes.REQUIRED] = `This field is required`;\n          } else {\n            errors[ValidationTypes.REQUIRED] = \"\";\n          }\n        }\n        break;\n      case ValidationTypes.REGEX:\n        {\n          const {\n            meta: { pattern }\n          } = validation;\n          if (!new RegExp(pattern).test(value)) {\n            errors[ValidationTypes.REGEX] = `Field value doesn't match the pattern`;\n          } else {\n            errors[ValidationTypes.REGEX] = \"\";\n          }\n        }\n        break;\n      case ValidationTypes.LENGTH:\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (value.length < min) {\n            errors[ValidationTypes.LENGTH] = `Minimum length of ${min} is needed`;\n          } else if (value.length > max) {\n            errors[ValidationTypes.LENGTH] = `Maximum length of ${max} is allowed`;\n          } else {\n            errors[ValidationTypes.LENGTH] = \"\";\n          }\n        }\n        break;\n      case ValidationTypes.RANGE:\n        {\n          const {\n            meta: { min, max }\n          } = validation;\n          if (!(value > min && value < max)) {\n            errors[ValidationTypes.RANGE] = `The value should be in the range of ${min} and ${max}`;\n          } else {\n            errors[ValidationTypes.RANGE] = \"\";\n          }\n        }\n        break;\n      case ValidationTypes.JSON:\n        {\n          try {\n            JSON.parse(value);\n            errors[ValidationTypes.JSON] = \"\";\n          } catch (err) {\n            errors[ValidationTypes.JSON] = `Invalid JSON supplied`;\n          }\n        }\n        break;\n\n      case ValidationTypes.CUSTOM:\n        {\n          const {\n            meta: { name }\n          } = validation;\n          if (options && options.validators && options.validators[name]) {\n            const isInvalid = options.validators[name](value);\n            errors[ValidationTypes.CUSTOM] = isInvalid ? isInvalid : \"\";\n          } else {\n            console.error(\"No custom validator function specified\");\n          }\n        }\n        break;\n    }\n    return errors;\n  }, {});\n"],"sourceRoot":""}